/* Copyright 2019, Jens Geisler
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

cagem_dir: load_pathname;


unitX: transpose(matrix([1, 0, 0]));
unitY: transpose(matrix([0, 1, 0]));
unitZ: transpose(matrix([0, 0, 1]));

/* Procedure giving the homogeneous transformation matrix of the rotation about X-axis by an angle thetax. */
Trotx(thetax):= block([Toi],
     Toi: matrix([1, 0, 0, 0],[0, cos(thetax), -sin(thetax), 0],[0, sin(thetax), cos(thetax), 0],[0,0,0,1])
);


/* Procedure giving the homogeneous transformation matrix of the rotation about Y-axis by an angle thetay. */
Troty(thetay):= block([Toi],
     Toi: matrix([cos(thetay), 0, sin(thetay), 0],[0, 1, 0, 0],[-sin(thetay), 0, cos(thetay), 0],[0,0,0,1])
);

/* Procedure giving the homogeneous transformation matrix of the rotation about Z-axis by an angle thetaz. */
Trotz(thetaz):= block([Toi],
     Toi: matrix([cos(thetaz), -sin(thetaz), 0, 0],[sin(thetaz), cos(thetaz), 0, 0],[0, 0, 1, 0],[0,0,0,1])
);


/* Procedure giving the homogeneous transformation matrix of the rotation by an angle theta
   about an arbitrary axis whose direction cosines are equal to nx, ny and nz. */
Trotn(nx,ny,nz,theta):= block([Toi],
     Toi: matrix([nx*nx*(1-cos(theta))+cos(theta), nx*ny*(1-cos(theta))-nz*sin(theta), nx*nz*(1-cos(theta))-ny*sin(theta), 0],[nx*ny*(1-cos(theta))+nz*sin(theta), ny*ny*(1-cos(theta))+cos(theta), ny*nz*(1-cos(theta))-nx*sin(theta), 0],[nx*nz*(1-cos(theta))-ny*sin(theta), nx*nz*(1-cos(theta))+nx*sin(theta), nz*nz*(1-cos(theta))+cos(theta), 0],[0,0,0,1])
);

/* Procedure giving the homogeneous transformation matrix of the displacement about its coordinates x, y and z. */
Tdisp(x,y,z):= block([Toi],
     Toi: matrix([1,0,0,x],[0,1,0,y],[0,0,1,z],[0,0,0,1])
);

Telast(nbody, nframe):= block([Toi, xyz, ori, z_elast],
    z_elast: [concat(z_elast_, nbody, '_, nframe)[1], concat(z_elast_, nbody, '_, nframe)[2], concat(z_elast_, nbody, '_, nframe)[3]],
    xyz: ebody[nbody]@frame[nframe]@origin@M0 + apply("+", makelist(ebody[nbody]@frame[nframe]@origin@M1[i]*elastic_dof[nbody][i], i, 1, length(elastic_dof[nbody]))),
    ori: ebody[nbody]@frame[nframe]@ap@M0 + apply("+", makelist(ebody[nbody]@frame[nframe]@ap@M1[i]*elastic_dof[nbody][i], i, 1, length(elastic_dof[nbody]))),

    z_list: append(z_list, z_elast),
    node_forces: endcons([nbody, nframe, concat(z_elast_, nbody, '_, nframe)], node_forces), 
    Toi: Tdisp(z_elast[1], z_elast[2], z_elast[3]) . Tdisp(xyz[1, 1], xyz[2, 1], xyz[3, 1]) . addcol(addrow(ori, [0, 0, 0]), [0, 0, 0, 1])
);

applyForceInLocal(r, F, T0G):= block([Fin0],
    Fin0: submatrix(4, T0G, 4) . F,
    applyForceIn0(r, Fin0, T0G)
);


applyForceIn0(r, Fin0, T0G):= block([],
    [Fin0, crossmat(submatrix(4, T0G, 4) . r) . Fin0]
);


decomp(expr):= block([], if atom(expr) or subvarp(expr) then [] else append([op(expr)],  map(decomp, args(expr))));
exp_size(expr):= length(flatten(decomp(expr)));
/* simplify(x):= radcan(trigreduce(trigsimp(x)));  ratsimp, trigrat ?? */
/* simplify(x):= block([s0, s1, s2], s0: eval_string(string(ev(x, float))), s1: ratsimp(trigreduce(trigsimp(s0))), s2: ratsimp(trigsimp(s0)), if exp_size(s1)>exp_size(s2) then s2 else s1); */
/* simplify(x):= block([s0, s1, s2, s3], s0: x, s1: ratsimp(trigreduce(trigsimp(s0))), s2: ratsimp(trigsimp(s0)), if exp_size(s1)>exp_size(s2) then s3: s2 else s3:s1, ev(s3, float)); */
simplify(x):= block([s0, s1, s2, s3, s4], 
    s0: trigsimp(x),
    s1: ratsimp(trigreduce(s0)),
    s2: ratsimp(s0),
    if exp_size(s1)>exp_size(s2) then s3: s2 else s3:s1,
/*    s4: ratsimp(ev(s3, float)),*/
    s4: fullratsimp(s3),
    if exp_size(s3)>exp_size(s4) then s4 else s3
);


defstruct(sysdef_type (file, name, nbrdof, nbrcon, nbrbody, nbrin, nbrdep, gravity, mass, IG, T0G, vG, omega, aG, omegad, vGpartial, omegapartial, vGpartial_z, omegapartial_z, elasticpartial, BodyRef, ebody, elastic_dof_idx, z_list, node_forces, pi, pdi, pddi, qi, qdi, FinalTime, StepSave, StepMax, appliedF, appliedM, appliedFe, SIMPLIFY, WITH_LINEAR, WITH_ACCELERATIONS, u, external, d_external, ext_param));
defstruct(cagem_out (sys_rel, sys_abs, forces, f, constraints, params, f_lin, accelerations, outputs));
defstruct(bodyforces_type (R, MG, Re));
defstruct(lin_model (M, E, A, B, C, D, Ap, Apd, Apdd, dp_dq, dp_dp, dpd_dq, dpd_dqd, dpd_dp, dpd_dpd, dpdd_dq, dpdd_dqd, dpdd_dqdd, dpdd_dp, dpdd_dpd, dpdd_dpdd));

cagem(file):= block([output, i, appliedF, appliedM, appliedFe, T0G, accelerations],
    output: new(cagem_out),

    output@sys_rel: prepareKinematics(file),
    output@sys_abs: composeMotion(output@sys_rel),
    output@forces: computeForceBalance(output@sys_abs),
    
    appliedForcesZero(output@sys_abs),
    for i:1 thru output@sys_abs@nbrbody do T0G[i]: output@sys_abs@T0G[i],
    appliedForces(),
    
    for i: 1 thru output@sys_rel@nbrbody do (
        output@forces@R[i]: output@forces@R[i] + appliedF[i],
        output@forces@MG[i]: output@forces@MG[i] + appliedM[i],
        output@forces@Re[i]: output@forces@Re[i] + appliedFe[i]        
    ),
    
    output@f: generalizedBalance(output@sys_abs, output@forces),
    output@constraints: constraintForces(output@sys_abs, output@forces, [z]),
                    
    if output@sys_abs@SIMPLIFY=1 then (
        output@f: simplify(output@f),
        output@constraints: simplify(output@constraints)
    ),
    
    if output@sys_rel@WITH_LINEAR=1 then
        output@f_lin: linearize(output@f, output@sys_rel)
    else (
        output@f_lin: new(lin_model),
        output@f_lin@M: [],
        output@f_lin@E: [],
        output@f_lin@A: [],
        output@f_lin@B: [],
        output@f_lin@Ap: [],
        output@f_lin@Apd: [],
        output@f_lin@Apdd: [],
        output@f_lin@dp_dq: [],
        output@f_lin@dp_dp: [],
        output@f_lin@dpd_dq: [],
        output@f_lin@dpd_dqd: [],
        output@f_lin@dpd_dp: [],
        output@f_lin@dpd_dpd: [],
        output@f_lin@dpdd_dq: [],
        output@f_lin@dpdd_dqd: [],
        output@f_lin@dpdd_dqdd: [],
        output@f_lin@dpdd_dp: [],
        output@f_lin@dpdd_dpd: [],
        output@f_lin@dpdd_dpdd: []
    ),
    
        
output@params: listify(subset(setify(listofvars(output@f)), lambda([x], not((subvarp(x) and (op(x)=qdd or op(x)=qd or op(x)=q)) or member(x, output@sys_rel@u) or member(x, output@sys_rel@external) or member(x, output@sys_rel@d_external) or x=t)))),
    
    if output@sys_rel@WITH_ACCELERATIONS=1 then (
        output@accelerations: calcAccelerations(output@f, output@f_lin@M),
        if output@sys_abs@SIMPLIFY=1 then
            output@accelerations: simplify(output@accelerations),
        accelerations: output@accelerations
    ) else (
        output@accelerations: []
    ),
    
    output@outputs: modelOutputs(),
    
    if output@sys_rel@WITH_LINEAR=1 then
        output: linearizeOut(output)
    else (
        output@f_lin: new(lin_model),
        output@f_lin@C: [],
        output@f_lin@D: []
    ),
    
    output
);

/* CAGeM procedure */
prepareKinematics(file):= block([
    time0, timeKI1, timeKI2, timeSP1, timeSP2, timeCPP, timePLT,
    ssKI1, ssKI2, ssKI, ssSP1, ssSP2, ssSP, ssCPP, ssPLT,
    timeTEXFR, ssTEXFR, timeTEXEN, ssTEXEN, timeTotal, ss, mm, seconds,
    filePLT, fileTEXFR, fileTEXEN, fileCPP,
    nbrbodymax, nbrdofmax, nbrdepmax, 
    i, j, j_, k, k_, f, temp, phiG, pi, pdi, pddi, p, pd, pdd, q, nbr_relative, elastic_dof_idx, 
    SIMPLIFY, INPUTS, STATES, WITH_LINEAR, WITH_ACCELERATIONS, EXTERNAL, DEXT_VARS, EXT_VARS, EXT_PARAM, 
    title, mass, IG, gravity, T0G, TrefG, elastic_dof, ebody, BodyRef, T0Gd, R0G, R0Gd, MatRot, omega, omega_z, omega_, omegad, vG, vG_z, vG_, aG, nbrdof, nbrz, nbrbody, nbrdep, vGpartial, omegapartial, z_list: [], node_forces: [], vGpartial_z, omegapartial_z,
    qi, qdi, Ixx, Iyy, Izz, Ixy, Ixz, Iyz], 
    local(temp, phiG, mass, IG, gravity, T0G, TrefG, elastic_dof, ebody, BodyRef, T0Gd, R0G, R0Gd, MatRot, omega, omega_z, omega_, omegad, vG, vG_z, vG_, aG, vGpartial, omegapartial, vGpartial_z, omegapartial_, qi, qdi, Ixx, Iyy, Izz, Ixy, Ixz, Iyz, pi, pdi, pddi, p, pd, pdd, q, qi, qdi, FinalTime, StepSave, StepMax, EXTERNAL, DEXT_VARS, EXT_VARS, EXT_PARAM),


    /* Program initialization. */
    print("===================================================================="),
    print("CAGeM v1.2.4"),
    print("(\"Computed-Aided Generation of Motion\")"),
    print("===================================================================="),


    keepfloat: true,
    ratprint: false,
    load(file),

    /* Counter initialization. */
    time0: elapsed_run_time(),

    /* Option flags initialization. */
    if SIMPLIFY='SIMPLIFY then SIMPLIFY: 1,
    if WITH_LINEAR='WITH_LINEAR then WITH_LINEAR: 1,
    if WITH_ACCELERATIONS='WITH_ACCELERATIONS then WITH_ACCELERATIONS: 0,
    if WITH_LINEAR#1 then WITH_ACCELERATIONS: 0,
    if INPUTS='INPUTS then INPUTS: [],
    if STATES='STATES then STATES: [],
    if EXTERNAL='EXTERNAL then EXTERNAL: [],
    if EXT_PARAM='EXT_PARAM then EXT_PARAM: [],
    if FinalTime='FinalTime then FinalTime: 10.0,
    if StepSave='StepSave then StepSave: 0.01,
    if StepMax='StepMax then StepMax: 0.01,
    
    if not(member(TrefG, arrays)) then TrefG[0]: [],
    if not(member(elastic_dof, arrays)) then elastic_dof[0]: [],
    nbrbody: lmax(append(flatten(rest(arrayinfo(T0G), 2)), flatten(rest(arrayinfo(TrefG), 2)))),
    nbrdof: max(lmax(flatten(map(args, sublist(listofvars([listarray(T0G), listarray(TrefG), listarray(elastic_dof)]), lambda([x], subvarp(x) and op(x)='q))))), 0),
    nbrz: max(lmax(flatten(map(args, sublist(listofvars([listarray(T0G), listarray(TrefG)]), lambda([x], subvarp(x) and op(x)='z))))), 0),
    for i: 1 thru nbrz do z_list: endcons(z[i], z_list),
    if member('pi, arrays) then nbrdep: lmax(flatten(rest(arrayinfo(pi), 2))) else nbrdep: 0,
    if not(member(gravity, arrays)) then gravity: [0.0, 0.0, -9.81],
    nbrin: length(INPUTS),
            
    IG: makelist(zeromatrix(3, 3), i, 1, nbrbody),
    for i:1 thru nbrbody do (
        if member('Ixx, arrays) and member(i, flatten(rest(arrayinfo(Ixx), 2))) then IG[i][1, 1]: Ixx[i],
        if member('Iyy, arrays) and member(i, flatten(rest(arrayinfo(Iyy), 2))) then IG[i][2, 2]: Iyy[i],
        if member('Izz, arrays) and member(i, flatten(rest(arrayinfo(Izz), 2))) then IG[i][3, 3]: Izz[i],
        if member('Ixy, arrays) and member(i, flatten(rest(arrayinfo(Ixy), 2))) then (IG[i][1, 2]: Ixy[i], IG[i][2, 1]: Ixy[i]),
        if member('Ixz, arrays) and member(i, flatten(rest(arrayinfo(Ixz), 2))) then (IG[i][1, 3]: Ixz[i], IG[i][3, 1]: Ixz[i]),
        if member('Iyz, arrays) and member(i, flatten(rest(arrayinfo(Iyz), 2))) then (IG[i][2, 3]: Iyz[i], IG[i][3, 2]: Iyz[i])
    ),
    for i:1 thru nbrdof do (
        if not(member('qi, arrays)) or not(member(i, flatten(rest(arrayinfo(qi), 2)))) then qi[i]: 0.0,
        if not(member('qdi, arrays)) or not(member(i, flatten(rest(arrayinfo(qdi), 2)))) then qdi[i]: 0.0
    ),
    
    EXT_VARS: [],
    DEXT_VARS: [],
    kill(gradefs),
    for i: 1 thru length(EXTERNAL) do (
        f_name: op(EXTERNAL[i]),
        f_args: args(EXTERNAL[i]),
           
        EXT_VARS: endcons(f_name, EXT_VARS),
                                       
        for j: 1 thru length(f_args) do (
            if subvarp(f_args[j]) then
                f_arg: concat(op(f_args[j]), args(f_args[j])[1])
            else
                f_arg: f_args[j],
            df_darg: concat(d, f_name, "_d", f_arg),
            gradef(f_name, f_args[j], df_darg),
            DEXT_VARS: endcons(df_darg, DEXT_VARS)
        )
    ),
    
    nbr_relative: 0,
    zero_matrix:  zeromatrix(4, 4),
    zero_z_list: makelist(z_list[i]=0, i, 1, length(z_list)),
    for i:1 thru nbrbody do (
        if not(member(i, flatten(rest(arrayinfo(T0G), 2)))) or (T0G[i] = zero_matrix and BodyRef[i] # -1) then (
            index_relative[i]: 1,
            T0G[i]: TrefG[i],
            nbr_relative: nbr_relative+1
        ) else (
            index_relative[i]: 0
        ),
        if member(i, flatten(rest(arrayinfo(elastic_dof), 2))) then (
            elastic_dof[i]: sublist(elastic_dof[i], lambda([x], subvarp(x) and op(x)='q)),
            elastic_dof_idx[i]: flatten(map(args, elastic_dof[i]))
        ) else
            elastic_dof_idx[i]: []
            
        /*T0G[i]: float(T0G[i])*/
    ),

    printf(true, "Generating for system with ~d bodies (~d relative), ~d degrees of freedom, ~d dependent variables.~%", nbrbody, nbr_relative, nbrdof, nbrdep),
    
    print("Declaration of dependant variables"),
    /* Declaration of dependant variables. 
    for k: 1 thru nbrdep do
        depends(pi[k], t),*/
    depends(p, t),
    

    print("Creation of time dependence."),
    depends(q, t),

    for i: 1 thru length(z_list) do 
        depends(op(z_list[i]), t),
    
    print("Calculed kinematics (part one)."),
    /* Calculed kinematics (part one). */
    for i: 1 thru nbrbody do (
        T0Gd[i]: diff(T0G[i], t),
        vG[i]: submatrix(4, T0Gd[i], 1, 2, 3),
        vG_z[i]: simplify(vG[i]),
        vG[i]: simplify(subst(zero_z_list, vG[i])),
        
        R0G[i]: submatrix(4, T0G[i], 4),
        R0Gd[i]: submatrix(4, T0Gd[i], 4),
        MatRot[i]: R0Gd[i].transpose(R0G[i]),
        omega[i]: matrix([MatRot[i][3,2]], [MatRot[i][1,3]], [MatRot[i][2,1]]),
        omega_z[i]: simplify(omega[i]),
        omega[i]: simplify(subst(zero_z_list, omega[i])),
        
        T0G[i]: simplify(subst(zero_z_list, T0G[i])),
        T0Gd[i]: simplify(subst(zero_z_list, T0Gd[i]))        
    ),

    for k:1 thru nbrdep do
        pdi[k]: diff(pi[k],t),
    
    timeKI1: elapsed_run_time(),
    ssKI1: trunc(timeKI1-time0),

    print("Simplification of kinematics parameters (part one)"),
    /* Simplification of kinematics parameters (part one). */
    if SIMPLIFY=1 then (
        for i:1 thru nbrbody do (
            T0G[i]: simplify(T0G[i]),
            T0Gd[i]: simplify(T0Gd[i]),
            vG[i]: simplify(vG[i]),
            omega[i]: simplify(omega[i]),
            vG_z[i]: simplify(vG_z[i]),
            omega_z[i]: simplify(omega_z[i])
        ),
        
        for k: 1 thru nbrdep do
            pi[k]: simplify(pi[k]),
            pdi[k]: simplify(pdi[k])
    ),
    
    timeSP1: elapsed_run_time(),
    ssSP1: trunc(timeSP1-timeKI1),

    print("Complete calculed kinematics (part two)"),
    /* Complete calculed kinematics (part two). */
    for i:1 thru nbrbody do (
        aG[i]: diff(vG[i], t),
        omegad[i]: diff(omega[i], t)
    ),
    
    for k:1 thru nbrdep do
        pddi[k]: diff(pdi[k], t),

    timeKI2: elapsed_run_time(),
    ssKI2: trunc(timeKI2-timeSP1),

    print("Simplification of kinematics parameters (part two)"),
    /* Simplification of kinematics parameters (part two). */
    if SIMPLIFY=1 then (
        for i:1 thru nbrbody do (
            aG[i]: simplify(aG[i]),
            omegad[i]: simplify(omegad[i])
        ),
        for k:1 thru nbrdep do
            pddi[k]: simplify(pddi[k])
    ),
    
    timeSP2: elapsed_run_time(),
    ssSP2: trunc(timeSP2-timeKI2),

    
    print("Form modification of configuration parameters"),
    /* Form modification of configuration parameters. */
    /* TODO may be handled more elegantly by gradef */
    for i:1 thru nbrbody do (
        for j:1 thru nbrdof do (
            j_: j,
            vG[i]: subst(qdd[j_], diff(q[j],t,2), vG[i]),
            vG[i]: subst(qd[j_], diff(q[j],t), vG[i]),
            vG[i]: subst(q[j_], q[j], vG[i]),
            omega[i]: subst(qdd[j_], diff(q[j],t,2), omega[i]),
            omega[i]: subst(qd[j_], diff(q[j],t), omega[i]),
            omega[i]: subst(q[j_], q[j], omega[i]),
            vG_z[i]: subst(qdd[j_], diff(q[j],t,2), vG_z[i]),
            vG_z[i]: subst(qd[j_], diff(q[j],t), vG_z[i]),
            vG_z[i]: subst(q[j_], q[j], vG_z[i]),
            omega_z[i]: subst(qdd[j_], diff(q[j],t,2), omega_z[i]),
            omega_z[i]: subst(qd[j_], diff(q[j],t), omega_z[i]),
            omega_z[i]: subst(q[j_], q[j], omega_z[i]),
            aG[i]: subst(qdd[j_], diff(q[j],t,2), aG[i]),
            aG[i]: subst(qd[j_], diff(q[j],t), aG[i]),
            aG[i]: subst(q[j_], q[j], aG[i]),
            omegad[i]: subst(qdd[j_], diff(q[j],t,2), omegad[i]),
            omegad[i]: subst(qd[j_], diff(q[j],t), omegad[i]),
            omegad[i]: subst(q[j_], q[j], omegad[i]),
            T0G[i]: subst(qdd[j_], diff(q[j],t,2), T0G[i]),
            T0G[i]: subst(qd[j_], diff(q[j],t), T0G[i]),
            T0G[i]: subst(q[j_], q[j], T0G[i]),
            T0Gd[i]: subst(qdd[j_], diff(q[j],t,2), T0Gd[i]),
            T0Gd[i]: subst(qd[j_], diff(q[j],t), T0Gd[i]),
            T0Gd[i]: subst(q[j_], q[j], T0Gd[i])
        ),
        for j:1 thru nbrdep do (
            j_: j,
            vG[i]: subst(pdd[j_], diff(p[j],t,2), vG[i]),
            vG[i]: subst(pd[j_], diff(p[j],t), vG[i]),
            vG[i]: subst(p[j_], p[j], vG[i]),
            omega[i]: subst(pdd[j_], diff(p[j],t,2), omega[i]),
            omega[i]: subst(pd[j_], diff(p[j],t), omega[i]),
            omega[i]: subst(p[j_], p[j], omega[i]),
            vG_z[i]: subst(pdd[j_], diff(p[j],t,2), vG_z[i]),
            vG_z[i]: subst(pd[j_], diff(p[j],t), vG_z[i]),
            vG_z[i]: subst(p[j_], p[j], vG_z[i]),
            omega_z[i]: subst(pdd[j_], diff(p[j],t,2), omega_z[i]),
            omega_z[i]: subst(pd[j_], diff(p[j],t), omega_z[i]),
            omega_z[i]: subst(p[j_], p[j], omega_z[i]),
            aG[i]: subst(pdd[j_], diff(p[j],t,2), aG[i]),
            aG[i]: subst(pd[j_], diff(p[j],t), aG[i]),
            aG[i]: subst(p[j_], p[j], aG[i]),
            omegad[i]: subst(pdd[j_], diff(p[j],t,2), omegad[i]),
            omegad[i]: subst(pd[j_], diff(p[j],t), omegad[i]),
            omegad[i]: subst(p[j_], p[j], omegad[i]),
            T0G[i]: subst(pdd[j_], diff(p[j],t,2), T0G[i]),
            T0G[i]: subst(pd[j_], diff(p[j],t), T0G[i]),
            T0G[i]: subst(p[j_], p[j], T0G[i]),
            T0Gd[i]: subst(pdd[j_], diff(p[j],t,2), T0Gd[i]),
            T0Gd[i]: subst(pd[j_], diff(p[j],t), T0Gd[i]),
            T0Gd[i]: subst(p[j_], p[j], T0Gd[i])
        ),
        for j:1 thru length(z_list) do (
            j_: j,
            vG_z[i]: subst(zd[j_], diff(z_list[j],t), vG_z[i]),
            omega_z[i]: subst(zd[j_], diff(z_list[j],t), omega_z[i])
        )
    ),
    for k:1 thru nbrdep do (
        for j:1 thru nbrdof do (
            j_: j,
            pi[k]: subst(q[j_], q[j], pi[k]),
            pdi[k]: subst(qd[j_], diff(q[j],t), pdi[k]),
            pdi[k]: subst(q[j_], q[j], pdi[k]),
            pddi[k]: subst(qdd[j_], diff(q[j],t, 2), pddi[k]),
            pddi[k]: subst(qd[j_], diff(q[j],t), pddi[k]),
            pddi[k]: subst(q[j_], q[j], pddi[k])
        ),
        for j:1 thru nbrdep do (
            j_: j,
            pi[k]: subst(p[j_], p[j], pi[k]),
            pdi[k]: subst(pd[j_], diff(p[j],t), pdi[k]),
            pdi[k]: subst(p[j_], p[j], pdi[k]),
            pddi[k]: subst(pdd[j_], diff(p[j],t, 2), pddi[k]),
            pddi[k]: subst(pd[j_], diff(p[j],t), pddi[k]),
            pddi[k]: subst(p[j_], p[j], pddi[k])
        )
    ),

    print("Complete calculed kinematics (part three)"),
    /* Complete calculed kinematics (part three). */
    for i:1 thru nbrbody do (
        for j:1 thru nbrdof do (
            j_: j,
            vG_: vG[i],
            omega_: omega[i],
            for k: nbrdep step -1 thru 1 do (
                k_: k,
                vG_: subst(pdi[k], pd[k_], vG_),
                vG_: subst(pi[k], p[k_], vG_),
                omega_: subst(pdi[k], pd[k_], omega_),
                omega_: subst(pi[k], p[k_], omega_)
            ),
            
            vGpartial[i, j]: diff(vG_, qd[j_]),
            omegapartial[i, j]: diff(omega_, qd[j_])
        ),
        for j:1 thru length(z_list) do (
            j_: j,
            for k: nbrdep step -1 thru 1 do (
                k_: k,
                vG_z[i]: subst(pdi[k], pd[k_], vG_z[i]),
                vG_z[i]: subst(pi[k], p[k_], vG_z[i]),
                omega_z[i]: subst(pdi[k], pd[k_], omega_z[i]),
                omega_z[i]: subst(pi[k], p[k_], omega_z[i])
            ),
            vGpartial_z[i, j]: diff(vG_z[i], zd[j_]),
            omegapartial_z[i, j]: diff(omega_z[i], zd[j_])
        )
    ),
    
    timeKI3: elapsed_run_time(),
    SSKI3: trunc(timeKI3-timeSP2),
    ssKI: ssKI1+ssKI2+SSKI3,
    printf(true, "... Kinematics computation finished ~,3h s.~%", ssKI),
                
    print("Simplification of kinematics parameters (part three)"),
    /* Simplification of kinematics parameters (part three). */
    if SIMPLIFY = 1 then (
        for i:1 thru nbrbody do (
            for j:1 thru nbrdof do (
                vGpartial[i,j]: simplify(vGpartial[i,j]),
                omegapartial[i,j]: simplify(omegapartial[i,j])
            ),
            for j:1 thru length(z_list) do (
                vGpartial_z[i,j]: simplify(vGpartial_z[i,j]),
                omegapartial_z[i,j]: simplify(omegapartial_z[i,j])
            )
        )
    ),
    
    timeSP3: elapsed_run_time(),
    ssSP3: trunc(timeSP3-timeKI3),
    ssSP: ssSP1+ssSP2+ssSP3, 
    printf(true, "... Kinematics simplification finished in ~,3h s.~%", ssSP),
    
    /* Total CPU-time. */
    timeTotal: elapsed_run_time(),
    ss: timeTotal-time0,
    mm: floor(ss/60),
    totseconds:trunc(ss-mm*60),
    printf(true, "All the operations are finished. Total CPU-time in Maxima: ~d:~6,3,,,,'0h min.~%", mm, totseconds),
    
    sysdef: new(sysdef_type),

    sysdef@file: file,
    sysdef@name: title,
    sysdef@nbrdof: nbrdof,
    sysdef@nbrcon: length(z_list),
    sysdef@nbrbody: nbrbody,
    sysdef@nbrin: nbrin,
    sysdef@nbrdep: nbrdep,
    sysdef@gravity: makelist(gravity[i], i, 1, 3),
    sysdef@mass: makelist(mass[i], i, 1, nbrbody),
    sysdef@IG: makelist(IG[i], i, 1, nbrbody),
    sysdef@T0G: makelist(T0G[i], i, 1, nbrbody),
    sysdef@vG: makelist(vG[i], i, 1, nbrbody),
    sysdef@omega: makelist(omega[i], i, 1, nbrbody),
    sysdef@aG: makelist(aG[i], i, 1, nbrbody),
    sysdef@omegad: makelist(omegad[i], i, 1, nbrbody),
    sysdef@vGpartial: makelist(makelist(vGpartial[i, j], j, 1, nbrdof), i, 1, nbrbody),
    sysdef@vGpartial_z: makelist(makelist(vGpartial_z[i, j], j, 1, length(z_list)), i, 1, nbrbody),
    sysdef@elasticpartial: makelist([], i, 1, nbrbody),
    sysdef@omegapartial: makelist(makelist(omegapartial[i, j], j, 1, nbrdof), i, 1, nbrbody),
    sysdef@omegapartial_z: makelist(makelist(omegapartial_z[i, j], j, 1, length(z_list)), i, 1, nbrbody),
    sysdef@z_list: makelist(z_list[i], i, 1, length(z_list)),
    sysdef@node_forces: makelist(node_forces[i], i, 1, length(node_forces)),
    sysdef@BodyRef: makelist(BodyRef[i], i, 1, nbrbody),
    sysdef@ebody: makelist(ebody[i], i, 1, nbrbody),
    sysdef@elastic_dof_idx: makelist(elastic_dof_idx[i], i, 1, nbrbody),
    sysdef@pi: makelist(pi[i], i, 1, nbrdep),
    sysdef@pdi: makelist(pdi[i], i, 1, nbrdep),
    sysdef@pddi: makelist(pddi[i], i, 1, nbrdep),
    sysdef@qi: makelist(qi[i], i, 1, nbrdof),
    sysdef@qdi: makelist(qdi[i], i, 1, nbrdof),
    sysdef@FinalTime: FinalTime,
    sysdef@StepSave: StepSave,
    sysdef@StepMax: StepMax,
    sysdef@appliedF: makelist(appliedF[i], i, 1, nbrbody),
    sysdef@appliedM: makelist(appliedM[i], i, 1, nbrbody),
    sysdef@appliedFe: makelist(appliedFe[i], i, 1, nbrbody),
    sysdef@SIMPLIFY: SIMPLIFY,
    sysdef@WITH_LINEAR: WITH_LINEAR,
    sysdef@WITH_ACCELERATIONS: WITH_ACCELERATIONS,
    sysdef@u: INPUTS,
    sysdef@external: EXT_VARS,
    sysdef@d_external: DEXT_VARS,
    sysdef@ext_param: EXT_PARAM,
        
    sysdef
);


do_assign(n_work, e_work):= block([],
    gentran(lrsetq(eval(n_work), scanmap('float, subst(subst_list, e_work))))
);

cagem2c(sysdef, [target_dir]):= block([i, j, i_, j_, file, title, nbrdof, nbrbody, nbrin, nbrdep, gravity, mass, IG, T0G, vG, omega, aG, omegad, vGpartial, omegapartial, BodyRef, ebody, elastic_dof_idx, pi, pdi, pddi, qi, qdi, FinalTime, StepSave, StepMax],
    file: sysdef@file,
    title: sysdef@name,
    nbrdof: sysdef@nbrdof,
    nbrbody: sysdef@nbrbody,
    nbrin: sysdef@nbrin,
    nbrdep: sysdef@nbrdep,
    gravity: sysdef@gravity,
    mass: sysdef@mass,
    IG: sysdef@IG,
    T0G: sysdef@T0G,
    vG: sysdef@vG,
    omega: sysdef@omega,
    aG: sysdef@aG,
    omegad: sysdef@omegad,
    vGpartial: sysdef@vGpartial,
    omegapartial: sysdef@omegapartial,
    BodyRef: sysdef@BodyRef,
    ebody: sysdef@ebody,
    elastic_dof_idx: sysdef@elastic_dof_idx,
    pi: sysdef@pi,
    pdi: sysdef@pdi,
    pddi: sysdef@pddi,
    qi: sysdef@qi,
    qdi: sysdef@qdi,
    FinalTime: sysdef@FinalTime,
    StepSave: sysdef@StepSave,
    StepMax: sysdef@StepMax,
    
    for i:1 thru nbrbody do (
        for j:1 thru nbrdof do (
            j_: j-1,
            vG[i]: subst(qdd[j_], qdd[j], vG[i]),
            vG[i]: subst(qd[j_], qd[j], vG[i]),
            vG[i]: subst(q[j_], q[j], vG[i]),
            omega[i]: subst(qdd[j_], qdd[j], omega[i]),
            omega[i]: subst(qd[j_], qd[j], omega[i]),
            omega[i]: subst(q[j_], q[j], omega[i]),
            aG[i]: subst(qdd[j_], qdd[j], aG[i]),
            aG[i]: subst(qd[j_], qd[j], aG[i]),
            aG[i]: subst(q[j_], q[j], aG[i]),
            omegad[i]: subst(qdd[j_], qdd[j], omegad[i]),
            omegad[i]: subst(qd[j_], qd[j], omegad[i]),
            omegad[i]: subst(q[j_], q[j], omegad[i]),
            T0G[i]: subst(qdd[j_], qdd[j], T0G[i]),
            T0G[i]: subst(qd[j_], qd[j], T0G[i]),
            T0G[i]: subst(q[j_], q[j], T0G[i]),
            vGpartial[i]: subst(qdd[j_], qdd[j], vGpartial[i]),
            vGpartial[i]: subst(qd[j_], qd[j], vGpartial[i]),
            vGpartial[i]: subst(q[j_], q[j], vGpartial[i]),
            omegapartial[i]: subst(qdd[j_], qdd[j], omegapartial[i]),
            omegapartial[i]: subst(qd[j_], qd[j], omegapartial[i]),
            omegapartial[i]: subst(q[j_], q[j], omegapartial[i])
        ),
        for j:1 thru nbrdep do (
            j_: j-1,
            vG[i]: subst(pdd[j_], pdd[j], vG[i]),
            vG[i]: subst(pd[j_], pd[j], vG[i]),
            vG[i]: subst(p[j_], p[j], vG[i]),
            omega[i]: subst(pdd[j_], pdd[j], omega[i]),
            omega[i]: subst(pd[j_], pd[j], omega[i]),
            omega[i]: subst(p[j_], p[j], omega[i]),
            aG[i]: subst(pdd[j_], pdd[j], aG[i]),
            aG[i]: subst(pd[j_], pd[j], aG[i]),
            aG[i]: subst(p[j_], p[j], aG[i]),
            omegad[i]: subst(pdd[j_], pdd[j], omegad[i]),
            omegad[i]: subst(pd[j_], pd[j], omegad[i]),
            omegad[i]: subst(p[j_], p[j], omegad[i]),
            T0G[i]: subst(pdd[j_], pdd[j], T0G[i]),
            T0G[i]: subst(pd[j_], pd[j], T0G[i]),
            T0G[i]: subst(p[j_], p[j], T0G[i]),
            vGpartial[i]: subst(pdd[j_], pdd[j], vGpartial[i]),
            vGpartial[i]: subst(pd[j_], pd[j], vGpartial[i]),
            vGpartial[i]: subst(p[j_], p[j], vGpartial[i]),
            omegapartial[i]: subst(pdd[j_], pdd[j], omegapartial[i]),
            omegapartial[i]: subst(pd[j_], pd[j], omegapartial[i]),
            omegapartial[i]: subst(p[j_], p[j], omegapartial[i])
        )
    ),
    for i:1 thru nbrdep do (
        for j:1 thru nbrdof do (
            j_: j-1,
            pi[i]: subst(qdd[j_], qdd[j], pi[i]),
            pi[i]: subst(qd[j_], qd[j], pi[i]),
            pi[i]: subst(q[j_], q[j], pi[i]),
            pdi[i]: subst(qdd[j_], qdd[j], pdi[i]),
            pdi[i]: subst(qd[j_], qd[j], pdi[i]),
            pdi[i]: subst(q[j_], q[j], pdi[i]),
            pddi[i]: subst(qdd[j_], qdd[j], pddi[i]),
            pddi[i]: subst(qd[j_], qd[j], pddi[i]),
            pddi[i]: subst(q[j_], q[j], pddi[i])
        ),
        for j:1 thru nbrdep do (
            j_: j-1,
            pi[i]: subst(pdd[j_], pdd[j], pi[i]),
            pi[i]: subst(pd[j_], pd[j], pi[i]),
            pi[i]: subst(p[j_], p[j], pi[i]),
            pdi[i]: subst(pdd[j_], pdd[j], pdi[i]),
            pdi[i]: subst(pd[j_], pd[j], pdi[i]),
            pdi[i]: subst(p[j_], p[j], pdi[i]),
            pddi[i]: subst(pdd[j_], pdd[j], pddi[i]),
            pddi[i]: subst(pd[j_], pd[j], pddi[i]),
            pddi[i]: subst(p[j_], p[j], pddi[i])
        )
    ),
    
    filepath: pathname_directory(file),
    if length(target_dir)>0 then (
        filepath: target_dir[1],
        if slength(filepath)>0 then
            if notequal(substring (filepath, slength(filepath), slength(filepath)+1),"/") then
                filepath: sconcat(filepath, "/")
    ),
    filename: pathname_name(file),
    
    load("gentran"),
    gentranlang(c),
    on('float),
    off('gentranseg),
    ?clinelen\*: 1000,            
    user_file: sconcat(filename, ".AppEff.hpp"),
    gentranin(filename_merge(cagem_dir, "cadyn_cpp.tem"), [openw(sconcat(filepath, filename, "System.hpp"))]),
                                      
    app_file: sconcat(filepath, filename, "_app.cpp"),
    if file_search(app_file)=false then
        gentranin(filename_merge(cagem_dir, "cadyn_cpp_app.tem"), [openw(app_file)])
);


genopt(l):= block([o, temps, replace_list, i],
    o: optimize(l),

    if length(o)=length(l) then
        return(o),
        
    temps: inpart(o, 1),

    pre_replace_list: makelist(temps[i]=concat(temp, i), i, 1, length(temps)),
    replace_list: [],
    
    for i: 1 thru length(temps) do (
        if not(listp(inpart(o, i+1, 2)) or matrixp(inpart(o, i+1, 2))) then (
            gentran(literal("        double ")),
            do_assign(concat(temp, i), subst(pre_replace_list, inpart(o, i+1, 2))),
            replace_list: endcons(pre_replace_list[i], replace_list)
        ) else (
            replace_list: endcons(inpart(o, i+1, 1)=inpart(o, i+1, 2), replace_list)
        )
    ),

    subst(replace_list, inpart(o, length(temps)+2))
);

genmat(M, n, m, on, om, name):= block([i, j, i_, j_],
    for i:1 thru n do (
        i_: i-1,
        for j:1 thru m do (
            j_: j-1,
            if listp(M) then
                do_assign(concat(name, "(", i_, ", ", j_, ")"), M[(on+i-1)*m + om+j])
            else
                do_assign(concat(name, "(", i_, ", ", j_, ")"), M[on+i, om+j])
        )
    )    
);

make_c_index(v, nbrdof, nbrdep):= block([v_, j, j_],
    v_: v,

    for j:1 thru nbrdof do (
        j_: j-1,
        
        v_: subst(qdd[j_], qdd[j], v_),
        v_: subst(qd[j_], qd[j], v_),
        v_: subst(q[j_], q[j], v_)
    ),
    
    for j:1 thru nbrdep do (
        j_: j-1,
        
        v_: subst(pdd[j_], pdd[j], v_),
        v_: subst(pd[j_], pd[j], v_),
        v_: subst(p[j_], p[j], v_)
    ),
    
    v_
);

cagem2c2(sysdef, [target_dir]):= block([i, j, i_, j_, file, title, nbrdof, nbrbody, nbrin, nbrdep, external, d_external, params, E, A, Ap, Apd, Apdd, f, pi, pdi, pddi, dp_dq, dp_dp, dpd_dq, dpd_dqd, dpd_dp, dpd_dpd, dpdd_dq, dpdd_dqd, dpdd_dqdd, dpdd_dp, dpdd_dpd, dpdd_dpdd, qi, qdi, FinalTime, StepSave, StepMax],
    file: sysdef@sys_rel@file,
    title: sysdef@sys_rel@name,
    nbrdof: sysdef@sys_rel@nbrdof,
    nbrbody: sysdef@sys_rel@nbrbody,
    nbrin: sysdef@sys_rel@nbrin,
    u: sysdef@sys_rel@u,
    external: sysdef@sys_rel@external,
    d_external: sysdef@sys_rel@d_external,
    params: append(sysdef@params, sysdef@sys_rel@ext_param),
    nbrdep: sysdef@sys_rel@nbrdep,
    qi: sysdef@sys_abs@qi,
    qdi: sysdef@sys_abs@qdi,
    FinalTime: sysdef@sys_abs@FinalTime,
    StepSave: sysdef@sys_abs@StepSave,
    StepMax: sysdef@sys_abs@StepMax,
    
    E: make_c_index(sysdef@f_lin@E, nbrdof, nbrdep),
    A: make_c_index(sysdef@f_lin@A, nbrdof, nbrdep),
    B: make_c_index(sysdef@f_lin@B, nbrdof, nbrdep),
    Ap: make_c_index(sysdef@f_lin@Ap, nbrdof, nbrdep),
    Apd: make_c_index(sysdef@f_lin@Apd, nbrdof, nbrdep),
    Apdd: make_c_index(sysdef@f_lin@Apdd, nbrdof, nbrdep),
    dp_dq: make_c_index(sysdef@f_lin@dp_dq, nbrdof, nbrdep),
    dp_dp: make_c_index(sysdef@f_lin@dp_dp, nbrdof, nbrdep),
    dpd_dq: make_c_index(sysdef@f_lin@dpd_dq, nbrdof, nbrdep),
    dpd_dqd: make_c_index(sysdef@f_lin@dpd_dqd, nbrdof, nbrdep),
    dpd_dp: make_c_index(sysdef@f_lin@dpd_dp, nbrdof, nbrdep),
    dpd_dpd: make_c_index(sysdef@f_lin@dpd_dpd, nbrdof, nbrdep),
    dpdd_dq: make_c_index(sysdef@f_lin@dpdd_dq, nbrdof, nbrdep),
    dpdd_dqd: make_c_index(sysdef@f_lin@dpdd_dqd, nbrdof, nbrdep),
    dpdd_dqdd: make_c_index(sysdef@f_lin@dpdd_dqdd, nbrdof, nbrdep),
    dpdd_dp: make_c_index(sysdef@f_lin@dpdd_dp, nbrdof, nbrdep),
    dpdd_dpd: make_c_index(sysdef@f_lin@dpdd_dpd, nbrdof, nbrdep),
    dpdd_dpdd: make_c_index(sysdef@f_lin@dpdd_dpdd, nbrdof, nbrdep),

    f: make_c_index(sysdef@f, nbrdof, nbrdep),
    pi: make_c_index(sysdef@sys_abs@pi, nbrdof, nbrdep),
    pdi: make_c_index(sysdef@sys_abs@pdi, nbrdof, nbrdep),
    pddi: make_c_index(sysdef@sys_abs@pddi, nbrdof, nbrdep),
    
    subst_list: [],
    for i:1 thru nbrin do
        subst_list: endcons(sysdef@sys_rel@u[i]='u[i-1], subst_list),
    for i:1 thru length(sysdef@params) do
        subst_list: endcons(sysdef@params[i]=concat('param\., sysdef@params[i]), subst_list),

    filepath: pathname_directory(file),
    if length(target_dir)>0 then (
        filepath: target_dir[1],
        if slength(filepath)>0 then
            if notequal(substring (filepath, slength(filepath), slength(filepath)+1),"/") then
                filepath: sconcat(filepath, "/")
    ),
    filename: pathname_name(file),
    
    load("gentran"),
    gentranlang(c),
    on('float),
    off('gentranseg),
    ?clinelen\*: 1000,            
    gentranin(filename_merge(cagem_dir, "cadyn2_cpp.tem"), [openw(sconcat(filepath, filename, "System2.hpp"))]),
                                      
    ext_file: sconcat(filepath, filename, "System_Externals.hpp"),
    if file_search(ext_file)=false then (
        ext_file_source: sconcat(pathname_directory(file), filename, "System_Externals.hpp"),
        
        if not(file_search(ext_file_source)=false) then (
            load(operatingsystem),
            copy_file(ext_file_source, ext_file)
        ) else (
            gentranin(filename_merge(cagem_dir, "cadyn2_external_hpp.tem"), [openw(ext_file)])
        )
    ),
    
    app_file: sconcat(filepath, filename, "_app2.cpp"),
    /* if file_search(app_file)=false then */
    gentranin(filename_merge(cagem_dir, "cadyn2_cpp_app.tem"), [openw(app_file)])
);


cross(a, b):= [
    a[2]*b[3]-a[3]*b[2],
    a[3]*b[1]-a[1]*b[3],
    a[1]*b[2]-a[2]*b[1]
];

crossmat(x):= block(
    x: flatten(args(x)),
    matrix([0, -x[3], x[2]], [x[3], 0, -x[1]], [-x[2], x[1], 0])
);

/* TODO: add ksigma */
defstruct(modal (refmod, frame, I, md, Ct, Cr, Me, Gr, Oe, Ge, K, D));
defstruct(mtaylor (order, nrow, ncol, nelem, nq, nqn, struct, M0, M1, Mn));
defstruct(refmod (mass, nelastq, ielastq));
defstruct(frame (name, origin, ap, phi, psi, sigma));

makeEmptyTaylor(order, nrow, ncol, nelem, nq, nqn, struct):= block([t],
    t: new(mtaylor),
    t@order: order,
    t@nrow: nrow,
    t@ncol: ncol,
    t@nelem: nelem,
    t@nq: nq,
    t@nqn: nqn,
    t@struct: struct,
    
    if nelem>0 then
        t@M0: makelist(zeromatrix(nrow, ncol), i, 1, nelem)
    else
        t@M0: zeromatrix(nrow, ncol),
    
    if order>0 then
        t@M1: makelist(copy(t@M0), i, 1, nq),
            
    if order>1 then
        error("Elements of class taylor with order > 1 currently not supported"),
            
    t
);

emptyElasticFrame(nedof, name):= block([f],
    f: new(frame),

    f@name: name,

    f@origin: makeEmptyTaylor(1, 3, 1, 0, nedof, 0, 3),
    f@ap: makeEmptyTaylor(1, 3, 3, 0, nedof, 0, 3),

    f@phi: makeEmptyTaylor(1, 3, nedof, 0, nedof, 0, 3),
    f@psi: makeEmptyTaylor(0, 3, nedof, 0, nedof, 0, 3),
    f@sigma: makeEmptyTaylor(1, 6, 1, 0, nedof, 0, 3),

    f
);
    
emptyElasticMode(nedof, [frames]):= block([b, rm],
    b: new(modal),
    
    rm: new(refmod),
    
    rm@mass: 0,
    rm@nelastq: nedof,
    rm@ielastq: makelist(sconcat("Noname DOF", i), i, 1, nedof),
    
    b@refmod: rm,
    
    if length(frames)>0 then
        b@frame: makelist(emptyElasticFrame(nedof, sconcat("frame", i)), i, 1, frames[1])
    else
        b@frame: [],
    
    b@md: makeEmptyTaylor(1, 3, 1, 0, nedof, 0, 3),
    b@I: makeEmptyTaylor(1, 3, 3, 0, nedof, 0, 2), /* 2nd order element currently not supported */
    b@Ct: makeEmptyTaylor(1, nedof, 3, 0, nedof, 0, 3),
    b@Cr: makeEmptyTaylor(1, nedof, 3, 0, nedof, 0, 3),
    b@Me: makeEmptyTaylor(0, nedof, nedof, 0, nedof, 0, 2),
    b@Gr: makeEmptyTaylor(1, 3, 3, nedof, nedof, 0, 3),
    b@Ge: makeEmptyTaylor(0, nedof, 3, nedof, nedof, 0, 3),
    b@Oe: makeEmptyTaylor(1, nedof, 6, 0, nedof, 0, 3),
    b@K: makeEmptyTaylor(1, nedof, nedof, 0, nedof, 0, 2),
    b@D: makeEmptyTaylor(0, nedof, nedof, 0, nedof, 0, 2),

    b
);

genericEmptyTaylor(order, nrow, ncol, nelem, nq, nqn, struct, name):= block([t],
    t: new(mtaylor),
    t@order: order,
    t@nrow: nrow,
    t@ncol: ncol,
    t@nelem: nelem,
    t@nq: nq,
    t@nqn: nqn,
    t@struct: struct,
    
    name: eval_string(concat("'", name)),
    
    /* TODO: consider symmetric matrices */
    if nelem>0 then
        t@M0: makelist(genmatrix(lambda([i, j], concat(name, "0_", k, "__", i, "_", j)), nrow, ncol), k, 1, nelem)
    else
        t@M0: genmatrix(lambda([i, j], concat(name, "0_", i, "_", j)), nrow, ncol),
    
    if order>0 then
        if nelem>0 then
            t@M1: makelist(makelist(genmatrix(lambda([i, j], concat(name, "1_", l, "_", k, "__", i, "_", j)), nrow, ncol), k, 1, nelem), l, 1, nq)
        else
            t@M1: makelist(genmatrix(lambda([i, j], concat(name, "1_", l, "__", i, "_", j)), nrow, ncol), l, 1, nq),
        
            
    if order>1 then
        error("Elements of class taylor with order > 1 currently not supported"),
            
    t
);

genericElasticMode(nedof, name, [frames]):= block([b, rm],
    b: new(modal),
    
    rm: new(refmod),
    
    rm@mass: eval_string(concat("'", name, "_mass")),
    rm@nelastq: nedof,
    rm@ielastq: makelist(sconcat(name, " DOF", i), i, 1, nedof),
    
    b@refmod: rm,
    
    /* TODO add generic frames */
    if length(frames)>0 then
        b@frame: makelist(emptyElasticFrame(nedof, sconcat("frame", i)), i, 1, frames[1])
    else
        b@frame: [],
            
    b@md: genericEmptyTaylor(1, 3, 1, 0, nedof, 0, 3, concat(name, "_md")),
    b@I: genericEmptyTaylor(1, 3, 3, 0, nedof, 0, 2, concat(name, "_I")), /* 2nd order element currently not supported */
    b@Ct: genericEmptyTaylor(1, nedof, 3, 0, nedof, 0, 3, concat(name, "_Ct")),
    b@Cr: genericEmptyTaylor(1, nedof, 3, 0, nedof, 0, 3, concat(name, "_Cr")),
    b@Me: genericEmptyTaylor(0, nedof, nedof, 0, nedof, 0, 2, concat(name, "_Me")),
    b@Gr: genericEmptyTaylor(1, 3, 3, nedof, nedof, 0, 3, concat(name, "_Gr")),
    b@Ge: genericEmptyTaylor(0, nedof, 3, nedof, nedof, 0, 3, concat(name, "_Ge")),
    b@Oe: genericEmptyTaylor(1, nedof, 6, 0, nedof, 0, 3, concat(name, "_Oe")),
    b@K: genericEmptyTaylor(1, nedof, nedof, 0, nedof, 0, 2, concat(name, "_K")),
    b@D: genericEmptyTaylor(0, nedof, nedof, 0, nedof, 0, 2, concat(name, "_D")),

    b
);

calcElasticModeLumpedPrecomputed(PHI, rr, mm):= block([b, i, iPHI, jPHI, md, Ct, Cr, Me, Mee, Gr, Oe, Ge, Gee], 
    b: emptyElasticMode(length(PHI), length(PHI[1])),
    
    m: 0,
    for i:1 thru length(PHI[1]) do (
        m: m + mm[i]
    ),
    b@refmod@mass: m,
    
    I: zeromatrix(3, 3),
    for i:1 thru length(PHI[1]) do (
        I: I - crossmat(rr[i]).crossmat(rr[i])*mm[i]
    ),
    b@I@M0: I,
    
    md: zeromatrix(3, 1),
    for i:1 thru length(PHI[1]) do (
        md: md + transpose(matrix(rr[i]*mm[i]))
    ),
    b@md@M0: md,
    
    b@Ct@M0: zeromatrix(0, 3),
    for iPHI:1 thru length(PHI) do (
        Ct: [0, 0, 0],
        for i:1 thru length(PHI[1]) do (
            Ct: Ct + PHI[iPHI][i]*mm[i]
        ),
        b@Ct@M0: addrow(b@Ct@M0, Ct)
    ),

    b@Cr@M0: zeromatrix(0, 3),
    for iPHI:1 thru length(PHI) do (
        Cr: [0, 0, 0],
        for i:1 thru length(PHI[1]) do (
            Cr: Cr + cross(rr[i], PHI[iPHI][i])*mm[i]
        ),
        b@Cr@M0: addrow(b@Cr@M0, Cr)
    ),

    for iPHI:1 thru length(PHI) do (
        for jPHI:1 thru length(PHI) do (
            Me: 0,
            for i: 1 thru length(PHI[1]) do
                b@Me@M0[iPHI, jPHI]: b@Me@M0[iPHI, jPHI] + apply("+", PHI[iPHI][i]*PHI[jPHI][i])*mm[i]
        )
    ),
    
    for iPHI:1 thru length(PHI) do (
        Gr: zeromatrix(3, 3),
        for i:1 thru length(PHI[1]) do (
            Gr: Gr + 2*transpose(crossmat(rr[i])).crossmat(PHI[iPHI][i])*mm[i]
        ),
        b@Gr@M0[iPHI]: Gr
    ),
        
    for iPHI:1 thru length(PHI) do (
        Gee: zeromatrix(0, 3),
        for jPHI:1 thru length(PHI) do (
            Ge: [0, 0, 0],
            for i: 1 thru length(PHI[1]) do
                Ge: Ge + 2*cross(PHI[iPHI][i], PHI[jPHI][i])*mm[i],
            Gee: addrow(Gee, Ge)
        ),
        b@Ge@M0[iPHI]: Gee
    ),
    
    for iPHI:1 thru length(PHI) do (
        for i:1 thru length(PHI[1]) do (
            b@Oe@M0[iPHI, 1]: b@Oe@M0[iPHI, 1]-(rr[i][3]*PHI[iPHI][i][3] + rr[i][2]*PHI[iPHI][i][2]) * mm[i], /* wx^2 */
            b@Oe@M0[iPHI, 2]: b@Oe@M0[iPHI, 2]-(rr[i][3]*PHI[iPHI][i][3] + rr[i][1]*PHI[iPHI][i][1]) * mm[i], /* wy^2 */
            b@Oe@M0[iPHI, 3]: b@Oe@M0[iPHI, 3]-(rr[i][2]*PHI[iPHI][i][2] + rr[i][1]*PHI[iPHI][i][1]) * mm[i], /* wz^2 */
            b@Oe@M0[iPHI, 4]: b@Oe@M0[iPHI, 4]+(rr[i][1]*PHI[iPHI][i][2] + rr[i][2]*PHI[iPHI][i][1]) * mm[i], /* wx*wy */
            b@Oe@M0[iPHI, 5]: b@Oe@M0[iPHI, 5]+(rr[i][2]*PHI[iPHI][i][3] + rr[i][3]*PHI[iPHI][i][2]) * mm[i], /* wy*wz */
            b@Oe@M0[iPHI, 6]: b@Oe@M0[iPHI, 6]+(rr[i][1]*PHI[iPHI][i][3] + rr[i][3]*PHI[iPHI][i][1]) * mm[i]  /* wx*wz */
        )
    ),

    for i:1 thru length(PHI[1]) do (
        b@frame[i]@origin@M0: transpose(matrix(rr[i])),
        b@frame[i]@ap@M0: ident(3),

        for iPHI:1 thru length(PHI) do (
            b@frame[i]@origin@M1[iPHI]: transpose(matrix(PHI[iPHI][i]))
        )
    ),
    
    b
);

evalModalTaylor(t, edof_idx):= block([r, i, j],
    r: copy(t@M0),
    
    if t@order>0 then
        for i: 1 thru t@nq do
            if t@nelem>0 then (
                for j: 1 thru t@nelem do
                    r[j]: r[j] + t@M1[i][j]*q[edof_idx[i]]
            ) else
                r: r + t@M1[i]*q[edof_idx[i]],
            
    r
);

simplify_(x):= x;


composeMotion(sysdef):= block([erel, vrel, vrel_z, arel, wrel, wrel_z, wdrel, vGpartial, omegapartial, vGpartial_z, omegapartial_z, elasticpartial],
    sysout: copy(sysdef),
    for i: 1 thru sysout@nbrbody do (
        vGpartial: zeromatrix(3, 0),
        omegapartial: zeromatrix(3, 0),
        vGpartial_z: zeromatrix(3, 0),
        omegapartial_z: zeromatrix(3, 0),
        elasticpartial: zeromatrix(0, sysout@nbrdof),
        for j: 1 thru sysout@nbrdof do (
            vGpartial: addcol(vGpartial, sysout@vGpartial[i][j]),
            omegapartial: addcol(omegapartial, sysout@omegapartial[i][j])
        ),
        for j: 1 thru sysout@nbrcon do (
            vGpartial_z: addcol(vGpartial_z, sysout@vGpartial_z[i][j]),
            omegapartial_z: addcol(omegapartial_z, sysout@omegapartial_z[i][j])
        ),
        sysout@vGpartial[i]: vGpartial,
        sysout@omegapartial[i]: omegapartial,
        sysout@vGpartial_z[i]: vGpartial_z,
        sysout@omegapartial_z[i]: omegapartial_z,
        
        if numberp(sysout@BodyRef[i]) then (
            erel: simplify_(submatrix(4, sysout@T0G[sysout@BodyRef[i]], 4) . submatrix(4, sysout@T0G[i], 1, 2, 3)),
            vrel: simplify_(submatrix(4, sysout@T0G[sysout@BodyRef[i]], 4) . sysout@vG[i]),
            arel: simplify_(submatrix(4, sysout@T0G[sysout@BodyRef[i]], 4) . sysout@aG[i]),
            wrel: simplify_(submatrix(4, sysout@T0G[sysout@BodyRef[i]], 4) . sysout@omega[i]),
            wdrel: simplify_(submatrix(4, sysout@T0G[sysout@BodyRef[i]], 4) . sysout@omegad[i]),

            sysout@T0G[i]: simplify_(sysout@T0G[sysout@BodyRef[i]] . sysout@T0G[i]),
            sysout@vG[i]: simplify_(sysout@vG[sysout@BodyRef[i]] + crossmat(sysout@omega[sysout@BodyRef[i]]) . erel + vrel),
            sysout@omega[i]: simplify_(sysout@omega[sysout@BodyRef[i]] + wrel),
            sysout@aG[i]: simplify_(sysout@aG[sysout@BodyRef[i]] + crossmat(sysout@omegad[sysout@BodyRef[i]]) . erel + crossmat(sysout@omega[sysout@BodyRef[i]]) . (crossmat(sysout@omega[sysout@BodyRef[i]]) . erel) + 2.0*crossmat(sysout@omega[sysout@BodyRef[i]]) . vrel + arel),
            sysout@omegad[i]: simplify_(sysout@omegad[sysout@BodyRef[i]] + crossmat(sysout@omega[sysout@BodyRef[i]]) . wrel + wdrel),
    
            vGpartial: zeromatrix(3, 0),
            omegapartial: zeromatrix(3, 0),
            vGpartial_z: zeromatrix(3, 0),
            omegapartial_z: zeromatrix(3, 0),
            for j: 1 thru sysout@nbrdof do (
                vrel: simplify_(submatrix(4, sysout@T0G[sysout@BodyRef[i]], 4) . col(sysout@vGpartial[i], j)),
                wrel: simplify_(submatrix(4, sysout@T0G[sysout@BodyRef[i]], 4) . col(sysout@omegapartial[i], j)),
                vGpartial: simplify_(addcol(vGpartial, col(sysout@vGpartial[sysout@BodyRef[i]], j) + crossmat(col(sysout@omegapartial[sysout@BodyRef[i]], j)) . erel + vrel)),
                omegapartial: simplify_(addcol(omegapartial, col(sysout@omegapartial[sysout@BodyRef[i]], j) + wrel))
            ),
            sysout@vGpartial[i]: vGpartial,
            sysout@omegapartial[i]: omegapartial,
            
            for j: 1 thru sysout@nbrcon do (
                vrel_z: simplify_(submatrix(4, sysout@T0G[sysout@BodyRef[i]], 4) . col(sysout@vGpartial_z[i], j)),
                wrel_z: simplify_(submatrix(4, sysout@T0G[sysout@BodyRef[i]], 4) . col(sysout@omegapartial_z[i], j)),
                vGpartial_z: simplify_(addcol(vGpartial_z, col(sysout@vGpartial_z[sysout@BodyRef[i]], j) + crossmat(col(sysout@omegapartial_z[sysout@BodyRef[i]], j)) . erel + vrel_z)),
                omegapartial_z: simplify_(addcol(omegapartial_z, col(sysout@omegapartial_z[sysout@BodyRef[i]], j) + wrel_z))
            ),
            sysout@vGpartial_z[i]: vGpartial_z,
            sysout@omegapartial_z[i]: omegapartial_z
        ),
        
        for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
            elasticpartial: addrow(elasticpartial, zeromatrix(1, sysout@nbrdof)),
            elasticpartial[iedof, sysout@elastic_dof_idx[i][iedof]]: 1
        ),
        sysout@elasticpartial[i]: elasticpartial
    ),
    
    sysout
);


computeForceBalance(sysdef):= block([R, MG, PhiG_local, aG_local, omegad_local, omega_local, R_local, MG_local, Re, Ct, Cr, Ct_, Gr, Gr_, w, Ge, Ge_, K, D, grav_local],
    bodyforces: new(bodyforces_type),
    
    for i: 1 thru sysdef@nbrbody do (
        if sysout@ebody[i] = ebody[i] then (
            R[i]: simplify_(sysdef@mass[i] * (sysdef@gravity - sysdef@aG[i])),

            PhiG_local: simplify_(submatrix(4, sysdef@T0G[i], 4) . sysdef@IG[i] . transpose(submatrix(4, sysdef@T0G[i], 4))),
            MG[i]: simplify_(-PhiG_local . sysdef@omegad[i] - crossmat(sysdef@omega[i]) . (PhiG_local . sysdef@omega[i])),
            Re[i]: []
        ) else (
            Re[i]: zeromatrix(length(sysout@elastic_dof_idx[i]), 1),
            aG_local: simplify_(transpose(submatrix(4, sysdef@T0G[i], 4)) . sysdef@aG[i]),
            omegad_local: simplify_(transpose(submatrix(4, sysdef@T0G[i], 4)) . sysdef@omegad[i]),
            omega_local: simplify_(transpose(submatrix(4, sysdef@T0G[i], 4)) . sysdef@omega[i]),

            R_local: simplify_(- sysdef@ebody[i]@refmod@mass * aG_local),
            R_local: simplify_(R_local - crossmat(omegad_local) . evalModalTaylor(sysdef@ebody[i]@md, sysdef@elastic_dof_idx[i])),
            Ct: evalModalTaylor(sysdef@ebody[i]@Ct, sysdef@elastic_dof_idx[i]),
            for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                R_local: R_local - transpose(row(Ct, iedof)) * qdd[sysout@elastic_dof_idx[i][iedof]]
            ),
            
            MG_local: simplify_(- evalModalTaylor(sysdef@ebody[i]@I, sysdef@elastic_dof_idx[i]) . omegad_local),
            MG_local: simplify_(MG_local - crossmat(evalModalTaylor(sysdef@ebody[i]@md, sysdef@elastic_dof_idx[i])) . aG_local),
            Cr: evalModalTaylor(sysdef@ebody[i]@Cr, sysdef@elastic_dof_idx[i]),
            for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                MG_local: MG_local - transpose(row(Cr, iedof)) * qdd[sysout@elastic_dof_idx[i][iedof]]
            ),
            for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                Re[i][iedof, 1]: simplify_(- row(Ct, iedof) . aG_local),
                Re[i][iedof, 1]: simplify_(Re[i][iedof, 1] - row(Cr, iedof) . omegad_local),
                for jedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                    Re[i][iedof, 1]: simplify_(Re[i][iedof, 1] - sysdef@ebody[i]@Me@M0[iedof, jedof] * qdd[sysout@elastic_dof_idx[i][jedof]])
                )
            ),
            R_local: R_local - simplify_(crossmat(omega_local) . (crossmat(evalModalTaylor(sysdef@ebody[i]@md, sysdef@elastic_dof_idx[i])) . omega_local)),
            Ct_: zeromatrix(3, 1),
            for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                Ct_: Ct_ + transpose(row(Ct, iedof)) * qd[sysout@elastic_dof_idx[i][iedof]]
            ),
            R_local: R_local - simplify_(2 * crossmat(omega_local) . Ct_),

            MG_local: MG_local - simplify_(crossmat(omega_local) . (evalModalTaylor(sysdef@ebody[i]@I, sysdef@elastic_dof_idx[i]) . omega_local)),
            Gr_: zeromatrix(3, 3),
            Gr: evalModalTaylor(sysdef@ebody[i]@Gr, sysdef@elastic_dof_idx[i]),
            for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                Gr_: Gr_ + Gr[iedof] * qd[sysout@elastic_dof_idx[i][iedof]]
            ),
            MG_local: MG_local - simplify_(Gr_ . omega_local),

            w: matrix([omega_local[1, 1]*omega_local[1, 1], omega_local[2, 1]*omega_local[2, 1], omega_local[3, 1]*omega_local[3, 1], omega_local[1, 1]*omega_local[2, 1], omega_local[2, 1]*omega_local[3, 1], omega_local[1, 1]*omega_local[3, 1]]),
            Re[i]: Re[i] - simplify_(evalModalTaylor(sysdef@ebody[i]@Oe, sysdef@elastic_dof_idx[i]) . transpose(w)),

            Ge: evalModalTaylor(sysdef@ebody[i]@Ge, sysdef@elastic_dof_idx[i]),
            for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                Ge_: zeromatrix(3, 1),
                for jedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                    /* TODO: check for correct order of jedof and iedof */
                    Ge_: Ge_ + transpose(row(Ge[jedof], iedof)) * qd[sysout@elastic_dof_idx[i][jedof]]
                ),
                Re[i][iedof, 1]: Re[i][iedof, 1] - simplify_(transpose(Ge_) . omega_local)
            ),

            K: evalModalTaylor(sysdef@ebody[i]@K, sysdef@elastic_dof_idx[i]),
            D: evalModalTaylor(sysdef@ebody[i]@D, sysdef@elastic_dof_idx[i]),
            for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                for jedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                    Re[i][iedof, 1]: Re[i][iedof, 1] - K[iedof, jedof] * q[sysout@elastic_dof_idx[i][jedof]],
                    Re[i][iedof, 1]: Re[i][iedof, 1] - D[iedof, jedof] * qd[sysout@elastic_dof_idx[i][jedof]]
                )
            ),

            R[i]: simplify_(submatrix(4, sysdef@T0G[i], 4) . R_local),
            MG[i]: simplify_(submatrix(4, sysdef@T0G[i], 4) . MG_local),
            
            R[i]: R[i] + sysdef@ebody[i]@refmod@mass * sysdef@gravity,

            grav_local: transpose(submatrix(4, sysdef@T0G[i], 4)) . sysdef@gravity,
            MG[i]: MG[i] + simplify_(submatrix(4, sysdef@T0G[i], 4) . crossmat(evalModalTaylor(sysdef@ebody[i]@md, sysdef@elastic_dof_idx[i])) . grav_local),
            for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                Re[i][iedof, 1]: Re[i][iedof, 1] + simplify_(row(Ct, iedof) . grav_local)
            )
        )
    ),
    bodyforces@R: makelist(R[i], i, 1, sysdef@nbrbody),
    bodyforces@MG: makelist(MG[i], i, 1, sysdef@nbrbody),
    bodyforces@Re: makelist(Re[i], i, 1, sysdef@nbrbody),
    
    bodyforces
);


generalizedBalance(sysdef, bodyforces):= block([f, ibody, inode, iedof, idof, iframe, force],
    f: zeromatrix(sysdef@nbrdof, 1),
    
    for ibody: 1 thru sysdef@nbrbody do (
        f: f - simplify_(transpose(sysdef@vGpartial[ibody]) . bodyforces@R[ibody]),
        f: f - simplify_(transpose(sysdef@omegapartial[ibody]) . bodyforces@MG[ibody])
    ),

    for inode: 1 thru length(sysdef@node_forces) do (
        ibody: sysdef@node_forces[inode][1],
        iframe: sysdef@node_forces[inode][2],
        node_force: sysdef@node_forces[inode][3],

        for iedof: 1 thru length(sysdef@elastic_dof_idx[ibody]) do (
            idof: sysout@elastic_dof_idx[ibody][iedof],
            bodyforces@Re[ibody]: bodyforces@Re[ibody] + transpose(matrix(constraintForces(sysdef, bodyforces, [node_force])) . sysdef@ebody[ibody]@frame[iframe]@phi@M1[idof]) * q[idof]
        )
    ),
        
    for ibody: 1 thru sysdef@nbrbody do (
        if length(sysdef@elastic_dof_idx[ibody]) > 0 then (
            f: f - simplify_(transpose(sysdef@elasticpartial[ibody]) . bodyforces@Re[ibody])
        )
    ),
    
    flatten(args(f))
);

constraintForces(sysdef, bodyforces, z_id):= block([g, inverse_idx, i],
    z_id: sublist(sysdef@z_list, lambda([x], (subvarp(x) and member(op(x), z_id)) or member(x, z_id))),
    inverse_idx: sublist_indices(sysdef@z_list, lambda([x], not(member(x, z_id)))),

    g: zeromatrix(length(z_id), 1),
    
    for i: 1 thru sysdef@nbrbody do (
        g: g + simplify_(transpose(apply(submatrix, append([sysdef@vGpartial_z[i]], inverse_idx))) . bodyforces@R[i]),
        g: g + simplify_(transpose(apply(submatrix, append([sysdef@omegapartial_z[i]], inverse_idx))) . bodyforces@MG[i])
    ),
    
    /* TODO add elastic body inner forces */
    flatten(args(g))
);

appliedForcesZero(sys):= (
    for i:1 thru sys@nbrbody do (
        appliedF[i]: zeromatrix(3, 1),
        appliedM[i]: zeromatrix(3, 1),
        appliedFe[i]: zeromatrix(length(sys@elastic_dof_idx[i]), 1)
    )
);

linearize(f, sys):= block([M, E, A, A1, A2, B, out, f_],
    out: new(lin_model),

    f_: transpose(matrix(f)),
    M: zeromatrix(length(f_), 0),
    for i: 1 thru length(f_) do (
        M: addcol(M, diff(f_, qdd[i]))
    ),
    E: ratsimp(mat_unblocker(diag_matrix(identfor(M), M))),
    /* E: subst([cos(3*q[2])=0, sin(3*q[2])=0, sin(q[2])=0, cos(q[2])=0, qd[2]^2=0], E)$ */
    /* E: ratsimp(taytorat(taylor(E, [q[0], q[1], qd[0], qd[1]], 0, 0))); */


    A1: zeromatrix(length(f_), 0),
    for i: 1 thru length(f_) do (
        A1: addcol(A1, diff(f_, q[i]))
    ),
    A2: zeromatrix(length(f_), 0),
    for i: 1 thru length(f_) do (
        A2: addcol(A2, diff(f_, qd[i]))
    ),
    A: ratsimp(mat_unblocker(matrix([zerofor(A1), identfor(A1)], [-A1, -A2]))),
    /* A: subst([cos(3*q[2])=0, sin(3*q[2])=0, sin(q[2])=0, cos(q[2])=0, qd[2]^2=0], A)$ */
    /* A: ratsimp(taytorat(taylor(A, [q[0], q[1], qd[0], qd[1]], 0, 0)));*/

    out@Ap: jacobian(f, makelist(p[i], i, 1, sys@nbrdep)),
    out@Apd: jacobian(f, makelist(pd[i], i, 1, sys@nbrdep)),
    out@Apdd: jacobian(f, makelist(pdd[i], i, 1, sys@nbrdep)),

    B: zeromatrix(length(f_), 0),
    for i: 1 thru length(sys@u) do (
        B: addcol(B, diff(f_, sys@u[i]))
    ),
    B: ratsimp(mat_unblocker(matrix([zerofor(B)], [-B]))),
    
    out@dp_dq: jacobian(sys@pi, makelist(q[i], i, 1, sys@nbrdof)),
    out@dp_dp: jacobian(sys@pi, makelist(p[i], i, 1, sys@nbrdep)),

    out@dpd_dq: jacobian(sys@pdi, makelist(q[i], i, 1, sys@nbrdof)),
    out@dpd_dqd: jacobian(sys@pdi, makelist(qd[i], i, 1, sys@nbrdof)),
    out@dpd_dp: jacobian(sys@pdi, makelist(p[i], i, 1, sys@nbrdep)),
    out@dpd_dpd: jacobian(sys@pdi, makelist(pd[i], i, 1, sys@nbrdep)),

    out@dpdd_dq: jacobian(sys@pddi, makelist(q[i], i, 1, sys@nbrdof)),
    out@dpdd_dqd: jacobian(sys@pddi, makelist(qd[i], i, 1, sys@nbrdof)),
    out@dpdd_dqdd: jacobian(sys@pddi, makelist(qdd[i], i, 1, sys@nbrdof)),
    out@dpdd_dp: jacobian(sys@pddi, makelist(p[i], i, 1, sys@nbrdep)),
    out@dpdd_dpd: jacobian(sys@pddi, makelist(pd[i], i, 1, sys@nbrdep)),
    out@dpdd_dpdd: jacobian(sys@pddi, makelist(pdd[i], i, 1, sys@nbrdep)),

    out@M: M,
    out@E: E,
    out@A: A,
    out@B: B,
    out
);

linearizeOut(sys):= block([Cq, Cqd],
    Cq: jacobian(sys@outputs, makelist(q[i], i, 1, sys@sys_abs@nbrdof)),
    Cqd: jacobian(sys@outputs, makelist(qd[i], i, 1, sys@sys_abs@nbrdof)),
    sys@f_lin@C: mat_unblocker(matrix([Cq, Cqd])),
    
    sys@f_lin@D: jacobian(sys@outputs, sys@sys_abs@u),
    
    sys
);

calcAccelerations(f, M):= block([QDD, f_],
    QDD: transpose(matrix(makelist(qdd[i], i, 1, length(f)))),
    f_: ratsimp(M.QDD-transpose(matrix(f))),
    
    flatten(args(invert(M).f_))
);

writeMATLABMat(fid, name, m):= block([i, j],
    printf(fid, "~a= [~%", name),
    for i: 1 thru length(m) do (
        printf(fid, "    "),
        for j: 1 thru length(transpose(m)) do (
            printf(fid, "~a", (ssubst(")", "]", ssubst("(", "[", string(m[i, j]))))),
            if j#length(transpose(m)) then
                printf(fid, ", ")
        ),
        if i=length(m) then
            printf(fid, "~%")
        else
            printf(fid, ";~%")
    ),
    printf(fid, "];~%")
);

writeMATLAB_nonlinear(file, f, y, lin):= block([i, fid],
    fid: openw(file),
    
    printf(fid, "f= [~%"),
    for i: 1 thru length(f) do (
        printf(fid, "    ~a~%", (ssubst(")", "]", ssubst("(", "[", string(f[i])))))
    ),
    printf(fid, "];~%~%"),

    printf(fid, "y= [~%"),
    for i: 1 thru length(y) do (
        printf(fid, "    ~a~%", (ssubst(")", "]", ssubst("(", "[", string(y[i])))))
    ),
    printf(fid, "];~%"),
    
    close(fid)
);

writeMATLAB_linear(file, f, y, lin):= block([i, fid],
    fid: openw(file),
    
    if length(lin)>0 and length(lin@E)>0 then (
        printf(fid, "~%"),
        writeMATLABMat(fid, "E", lin@E),
        printf(fid, "~%"),
        writeMATLABMat(fid, "A", lin@A),
        printf(fid, "~%"),
        writeMATLABMat(fid, "B", lin@B),
        printf(fid, "~%"),
        writeMATLABMat(fid, "C", lin@C),
        printf(fid, "~%"),
        writeMATLABMat(fid, "D", lin@D)
    ),
    
    close(fid)
);
