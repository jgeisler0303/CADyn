/* Copyright 2019, Jens Geisler
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

cagem_dir: load_pathname;


unitX: transpose(matrix([1, 0, 0]));
unitY: transpose(matrix([0, 1, 0]));
unitZ: transpose(matrix([0, 0, 1]));

/* Procedure giving the homogeneous transformation matrix of the rotation about X-axis by an angle thetax. */
Trotx(thetax):= block([Toi],
     Toi: matrix([1, 0, 0, 0],[0, cos(thetax), -sin(thetax), 0],[0, sin(thetax), cos(thetax), 0],[0,0,0,1])
);


/* Procedure giving the homogeneous transformation matrix of the rotation about Y-axis by an angle thetay. */
Troty(thetay):= block([Toi],
     Toi: matrix([cos(thetay), 0, sin(thetay), 0],[0, 1, 0, 0],[-sin(thetay), 0, cos(thetay), 0],[0,0,0,1])
);

/* Procedure giving the homogeneous transformation matrix of the rotation about Z-axis by an angle thetaz. */
Trotz(thetaz):= block([Toi],
     Toi: matrix([cos(thetaz), -sin(thetaz), 0, 0],[sin(thetaz), cos(thetaz), 0, 0],[0, 0, 1, 0],[0,0,0,1])
);


/* Procedure giving the homogeneous transformation matrix of the rotation by an angle theta
   about an arbitrary axis whose direction cosines are equal to nx, ny and nz. */
Trotn(nx,ny,nz,theta):= block([Toi],
     Toi: matrix([nx*nx*(1-cos(theta))+cos(theta), nx*ny*(1-cos(theta))-nz*sin(theta), nx*nz*(1-cos(theta))-ny*sin(theta), 0],[nx*ny*(1-cos(theta))+nz*sin(theta), ny*ny*(1-cos(theta))+cos(theta), ny*nz*(1-cos(theta))-nx*sin(theta), 0],[nx*nz*(1-cos(theta))-ny*sin(theta), nx*nz*(1-cos(theta))+nx*sin(theta), nz*nz*(1-cos(theta))+cos(theta), 0],[0,0,0,1])
);

/* Procedure giving the homogeneous transformation matrix of the displacement about its coordinates x, y and z. */
Tdisp(x,y,z):= block([Toi],
     Toi: matrix([1,0,0,x],[0,1,0,y],[0,0,1,z],[0,0,0,1])
);


applyForceInLocal(r, F, T0G):= block([Fin0],
    Fin0: submatrix(4, T0G, 4) . F,
    applyForceIn0(r, Fin0, T0G)
);


applyForceIn0(r, Fin0, T0G):= block([],
    [Fin0, crossmat(submatrix(4, T0G, 4) . r) . Fin0]
);


decomp(expr):= block([], if atom(expr) or subvarp(expr) then [] else append([op(expr)],  map(decomp, args(expr))));
exp_size(expr):= length(flatten(decomp(expr)));
/* simplify(x):= radcan(trigreduce(trigsimp(x)));  ratsimp, trigrat ?? */
/* simplify(x):= block([s0, s1, s2], s0: eval_string(string(ev(x, float))), s1: ratsimp(trigreduce(trigsimp(s0))), s2: ratsimp(trigsimp(s0)), if exp_size(s1)>exp_size(s2) then s2 else s1); */
/* simplify(x):= block([s0, s1, s2, s3], s0: x, s1: ratsimp(trigreduce(trigsimp(s0))), s2: ratsimp(trigsimp(s0)), if exp_size(s1)>exp_size(s2) then s3: s2 else s3:s1, ev(s3, float)); */
simplify(x):= block([s0, s1, s2, s3, s4], 
    s0: trigsimp(x),
    s1: ratsimp(trigreduce(s0)),
    s2: ratsimp(s0),
    if exp_size(s1)>exp_size(s2) then s3: s2 else s3:s1,
/*    s4: ratsimp(ev(s3, float)),*/
    s4: fullratsimp(s3),
    if exp_size(s3)>exp_size(s4) then s4 else s3
);


defstruct(sysdef_type (file, name, nbrdof, nbrbody, nbrin, nbrdep, gravity, mass, IG, T0G, vG, omega, aG, omegad, vGpartial, omegapartial, elasticpartial, BodyRef, ebody, elastic_dof_idx, pi, pdi, pddi, qi, qdi, FinalTime, StepSave, StepMax, appliedF, appliedM, appliedFe, SIMPLIFY, u));
defstruct(cagem_out (sys_rel, sys_abs, forces, f, params, f_lin, accelerations, outputs));
defstruct(bodyforces_type (R, MG, Re));
defstruct(lin_model (M, E, A, B));

cagem(file):= block([output, i, appliedF, appliedM, appliedFe, T0G, accelerations],
    output: new(cagem_out),

    output@sys_rel: prepareKinematics(file),
    output@sys_abs: composeMotion(output@sys_rel),
    output@forces: computeForceBalance(output@sys_abs),
    
    appliedForcesZero(output@sys_abs),
    for i:1 thru output@sys_abs@nbrbody do T0G[i]: output@sys_abs@T0G[i],
    appliedForces(),
    
    for i: 1 thru output@sys_rel@nbrbody do (
        output@forces@R[i]: output@forces@R[i] + appliedF[i],
        output@forces@MG[i]: output@forces@MG[i] + appliedM[i],
        output@forces@Re[i]: output@forces@Re[i] + appliedFe[i]        
    ),
    
    output@f: generalizedBalance(output@sys_abs, output@forces),
    if output@sys_abs@SIMPLIFY=1 then
        output@f: simplify(output@f),
    
    if WITH_LINEAR=1 then
        output@f_lin: linearize(output@f, output@sys_rel@u)
    else (
        output@f_lin@M: [],
        output@f_lin@E: [],
        output@f_lin@A: [],
        output@f_lin@B: []
    ),
    
        
    output@params: listify(subset(setify(listofvars(output@f)), lambda([x], not(subvarp(x) and (op(x)=qdd or op(x)=qd or op(x)=q)) or member(x, output@sys_rel@u)))),
    
    if WITH_ACCELERATIONS=1 then (
        output@accelerations: calcAccelerations(output@f, output@f_lin@M),
        if output@sys_abs@SIMPLIFY=1 then
            output@accelerations: simplify(output@accelerations),
        accelerations: output@accelerations
    ) else (
        output@accelerations: []
    ),
    
    output@outputs: modelOutputs(),
    
    output
);

/* CAGeM procedure */
prepareKinematics(file):= block([
    time0, timeKI1, timeKI2, timeSP1, timeSP2, timeCPP, timePLT,
    ssKI1, ssKI2, ssKI, ssSP1, ssSP2, ssSP, ssCPP, ssPLT,
    timeTEXFR, ssTEXFR, timeTEXEN, ssTEXEN, timeTotal, ss, mm, seconds,
    filePLT, fileTEXFR, fileTEXEN, fileCPP,
    nbrbodymax, nbrdofmax, nbrdepmax, 
    i, j, j_, k, k_, f, temp, phiG, pi, pdi, pddi, p, pd, pdd, q, nbr_relative, elastic_dof_idx, 
    SIMPLIFY, INPUTS, 
    title, mass, IG, gravity, T0G, TrefG, elastic_dof, ebody, BodyRef, T0Gd, R0G, R0Gd, MatRot, omega, omega_, omegad, vG, vG_, aG, nbrdof, nbrbody, nbrdep, vGpartial, omegapartial,
    qi, qdi, Ixx, Iyy, Izz, Ixy, Ixz, Iyz], 
    local(temp, phiG, mass, IG, gravity, T0G, TrefG, elastic_dof, ebody, BodyRef, T0Gd, R0G, R0Gd, MatRot, omega, omega_, omegad, vG, vG_, aG, vGpartial, omegapartial, qi, qdi, Ixx, Iyy, Izz, Ixy, Ixz, Iyz, pi, pdi, pddi, p, pd, pdd, q, qi, qdi, FinalTime, StepSave, StepMax),


    /* Program initialization. */
    print("===================================================================="),
    print("CAGeM v1.2.4"),
    print("(\"Computed-Aided Generation of Motion\")"),
    print("===================================================================="),


    keepfloat: true,
    ratprint: false,
    load(file),

    /* Counter initialization. */
    time0: elapsed_run_time(),

    /* Option flags initialization. */
    if SIMPLIFY='SIMPLIFY then SIMPLIFY: 1,
    if WITH_LINEAR='WITH_LINEAR then WITH_LINEAR: 0,
    if WITH_ACCELERATIONS='WITH_ACCELERATIONS then WITH_ACCELERATIONS: 0,
    if WITH_LINEAR#1 then WITH_ACCELERATIONS: 0,
    if INPUTS='INPUTS then INPUTS: 0,
    if FinalTime='FinalTime then FinalTime: 10.0,
    if StepSave='StepSave then StepSave: 0.01,
    if StepMax='StepMax then StepMax: 0.01,
    
    if not(member(TrefG, arrays)) then TrefG[0]: [],
    if not(member(elastic_dof, arrays)) then elastic_dof[0]: [],
    if nbrbody='nbrbody then nbrbody: lmax(append(flatten(rest(arrayinfo(T0G), 2)), flatten(rest(arrayinfo(TrefG), 2)))),
    if nbrdof='nbrdof then nbrdof: max(lmax(flatten(map(args, sublist(listofvars([listarray(T0G), listarray(TrefG), listarray(elastic_dof)]), lambda([x], subvarp(x) and op(x)='q))))), 0),
    if nbrcon='nbrcon then nbrcon: max(lmax(flatten(map(args, sublist(listofvars([listarray(T0G), listarray(TrefG)]), lambda([x], subvarp(x) and op(x)='z))))), 0),
    if nbrdep='nbrdep then if member('pi, arrays) then nbrdep: lmax(flatten(rest(arrayinfo(pi), 2))) else nbrdep: 0,
    if not(member(gravity, arrays)) then gravity: [0.0, 0.0, -9.81],
    nbrin: INPUTS,
            
    IG: makelist(zeromatrix(3, 3), i, 1, nbrbody),
    for i:1 thru nbrbody do (
        if member('Ixx, arrays) and member(i, flatten(rest(arrayinfo(Ixx), 2))) then IG[i][1, 1]: Ixx[i],
        if member('Iyy, arrays) and member(i, flatten(rest(arrayinfo(Iyy), 2))) then IG[i][2, 2]: Iyy[i],
        if member('Izz, arrays) and member(i, flatten(rest(arrayinfo(Izz), 2))) then IG[i][3, 3]: Izz[i],
        if member('Ixy, arrays) and member(i, flatten(rest(arrayinfo(Ixy), 2))) then (IG[i][1, 2]: Ixy[i], IG[i][2, 1]: Ixy[i]),
        if member('Ixz, arrays) and member(i, flatten(rest(arrayinfo(Ixz), 2))) then (IG[i][1, 3]: Ixz[i], IG[i][3, 1]: Ixz[i]),
        if member('Iyz, arrays) and member(i, flatten(rest(arrayinfo(Iyz), 2))) then (IG[i][2, 3]: Iyz[i], IG[i][3, 2]: Iyz[i])
    ),
    for i:1 thru nbrdof do (
        if not(member('qi, arrays)) or not(member(i, flatten(rest(arrayinfo(qi), 2)))) then qi[i]: 0.0,
        if not(member('qdi, arrays)) or not(member(i, flatten(rest(arrayinfo(qdi), 2)))) then qdi[i]: 0.0
    ),
    
    nbr_relative: 0,
    zero_matrix:  zeromatrix(4, 4),
    zero_z_list: makelist(z[i]=0, i, 1, nbrcon),
    for i:1 thru nbrbody do (
        if not(member(i, flatten(rest(arrayinfo(T0G), 2)))) or (T0G[i] = zero_matrix and BodyRef[i] # -1) then (
            index_relative[i]: 1,
            T0G[i]: TrefG[i],
            nbr_relative: nbr_relative+1
        ) else (
            index_relative[i]: 0
        ),
        if member(i, flatten(rest(arrayinfo(elastic_dof), 2))) then (
            elastic_dof[i]: sublist(elastic_dof[i], lambda([x], subvarp(x) and op(x)='q)),
            elastic_dof_idx[i]: flatten(map(args, elastic_dof[i]))
        ) else
            elastic_dof_idx[i]: []
            
        /*T0G[i]: float(T0G[i])*/
    ),

    printf(true, "Generating for system with ~d bodies (~d relative), ~d degrees of freedom, ~d dependent variables.~%", nbrbody, nbr_relative, nbrdof, nbrdep),
    
    print("Declaration of dependant variables"),
    /* Declaration of dependant variables. 
    for k: 1 thru nbrdep do
        depends(pi[k], t),*/
    depends(p, t),
    

    print("Creation of time dependence."),
    /* Creation of time dependence.
    for i: 1 thru nbrdof do
        depends(q[i], t),*/
    depends(q, t),
    depends(z, t),
    
    print("Calculed kinematics (part one)."),
    /* Calculed kinematics (part one). */
    for i: 1 thru nbrbody do (
        T0Gd[i]: diff(T0G[i], t),
        vG[i]: submatrix(4, T0Gd[i], 1, 2, 3),
        vG_z[i]: simplify(vG[i]),
        vG[i]: simplify(subst(zero_z_list, vG[i])),
        
        R0G[i]: submatrix(4, T0G[i], 4),
        R0Gd[i]: submatrix(4, T0Gd[i], 4),
        MatRot[i]: R0Gd[i].transpose(R0G[i]),
        omega[i]: matrix([MatRot[i][3,2]], [MatRot[i][1,3]], [MatRot[i][2,1]]),
        omega_z[i]: simplify(omega[i]),
        omega[i]: simplify(subst(zero_z_list, omega[i])),
        
        T0G[i]: simplify(subst(zero_z_list, T0G[i])),
        T0Gd[i]: simplify(subst(zero_z_list, T0Gd[i]))        
    ),

    for k:1 thru nbrdep do
        pdi[k]: diff(pi[k],t),
    
    timeKI1: elapsed_run_time(),
    ssKI1: trunc(timeKI1-time0),

    print("Simplification of kinematics parameters (part one)"),
    /* Simplification of kinematics parameters (part one). */
    if SIMPLIFY=1 then (
        for i:1 thru nbrbody do (
            T0G[i]: simplify(T0G[i]),
            T0Gd[i]: simplify(T0Gd[i]),
            vG[i]: simplify(vG[i]),
            omega[i]: simplify(omega[i])
        ),
        
        for k: 1 thru nbrdep do
            pi[k]: simplify(pi[k]),
            pdi[k]: simplify(pdi[k])
    ),
    
    timeSP1: elapsed_run_time(),
    ssSP1: trunc(timeSP1-timeKI1),

    print("Complete calculed kinematics (part two)"),
    /* Complete calculed kinematics (part two). */
    for i:1 thru nbrbody do (
        aG[i]: diff(vG[i], t),
        omegad[i]: diff(omega[i], t)
    ),
    
    for k:1 thru nbrdep do
        pddi[k]: diff(pdi[k], t),

    timeKI2: elapsed_run_time(),
    ssKI2: trunc(timeKI2-timeSP1),

    print("Simplification of kinematics parameters (part two)"),
    /* Simplification of kinematics parameters (part two). */
    if SIMPLIFY=1 then (
        for i:1 thru nbrbody do (
            aG[i]: simplify(aG[i]),
            omegad[i]: simplify(omegad[i])
        ),
        for k:1 thru nbrdep do
            pddi[k]: simplify(pddi[k])
    ),
    
    timeSP2: elapsed_run_time(),
    ssSP2: trunc(timeSP2-timeKI2),

    
    print("Form modification of configuration parameters"),
    /* Form modification of configuration parameters. */
    /* TODO may be handled more elegantly by gradef */
    for i:1 thru nbrbody do (
        for j:1 thru nbrdof do (
            j_: j,
            vG[i]: subst(qdd[j_], diff(q[j],t,2), vG[i]),
            vG[i]: subst(qd[j_], diff(q[j],t), vG[i]),
            vG[i]: subst(q[j_], q[j], vG[i]),
            omega[i]: subst(qdd[j_], diff(q[j],t,2), omega[i]),
            omega[i]: subst(qd[j_], diff(q[j],t), omega[i]),
            omega[i]: subst(q[j_], q[j], omega[i]),
            aG[i]: subst(qdd[j_], diff(q[j],t,2), aG[i]),
            aG[i]: subst(qd[j_], diff(q[j],t), aG[i]),
            aG[i]: subst(q[j_], q[j], aG[i]),
            omegad[i]: subst(qdd[j_], diff(q[j],t,2), omegad[i]),
            omegad[i]: subst(qd[j_], diff(q[j],t), omegad[i]),
            omegad[i]: subst(q[j_], q[j], omegad[i]),
            T0G[i]: subst(qdd[j_], diff(q[j],t,2), T0G[i]),
            T0G[i]: subst(qd[j_], diff(q[j],t), T0G[i]),
            T0G[i]: subst(q[j_], q[j], T0G[i]),
            T0Gd[i]: subst(qdd[j_], diff(q[j],t,2), T0Gd[i]),
            T0Gd[i]: subst(qd[j_], diff(q[j],t), T0Gd[i]),
            T0Gd[i]: subst(q[j_], q[j], T0Gd[i])
        ),
        for j:1 thru nbrdep do (
            j_: j,
            vG[i]: subst(pdd[j_], diff(p[j],t,2), vG[i]),
            vG[i]: subst(pd[j_], diff(p[j],t), vG[i]),
            vG[i]: subst(p[j_], p[j], vG[i]),
            omega[i]: subst(pdd[j_], diff(p[j],t,2), omega[i]),
            omega[i]: subst(pd[j_], diff(p[j],t), omega[i]),
            omega[i]: subst(p[j_], p[j], omega[i]),
            aG[i]: subst(pdd[j_], diff(p[j],t,2), aG[i]),
            aG[i]: subst(pd[j_], diff(p[j],t), aG[i]),
            aG[i]: subst(p[j_], p[j], aG[i]),
            omegad[i]: subst(pdd[j_], diff(p[j],t,2), omegad[i]),
            omegad[i]: subst(pd[j_], diff(p[j],t), omegad[i]),
            omegad[i]: subst(p[j_], p[j], omegad[i]),
            T0G[i]: subst(pdd[j_], diff(p[j],t,2), T0G[i]),
            T0G[i]: subst(pd[j_], diff(p[j],t), T0G[i]),
            T0G[i]: subst(p[j_], p[j], T0G[i]),
            T0Gd[i]: subst(pdd[j_], diff(p[j],t,2), T0Gd[i]),
            T0Gd[i]: subst(pd[j_], diff(p[j],t), T0Gd[i]),
            T0Gd[i]: subst(p[j_], p[j], T0Gd[i])
        )
    ),
    for k:1 thru nbrdep do (
        for j:1 thru nbrdof do (
            j_: j,
            pi[k]: subst(q[j_], q[j], pi[k]),
            pdi[k]: subst(qd[j_], diff(q[j],t), pdi[k]),
            pdi[k]: subst(q[j_], q[j], pdi[k]),
            pddi[k]: subst(qdd[j_], diff(q[j],t, 2), pddi[k]),
            pddi[k]: subst(qd[j_], diff(q[j],t), pddi[k]),
            pddi[k]: subst(q[j_], q[j], pddi[k])
        ),
        for j:1 thru nbrdep do (
            j_: j,
            pi[k]: subst(p[j_], p[j], pi[k]),
            pdi[k]: subst(pd[j_], diff(p[j],t), pdi[k]),
            pdi[k]: subst(p[j_], p[j], pdi[k]),
            pddi[k]: subst(pdd[j_], diff(p[j],t, 2), pddi[k]),
            pddi[k]: subst(pd[j_], diff(p[j],t), pddi[k]),
            pddi[k]: subst(p[j_], p[j], pddi[k])
        )
    ),

    print("Complete calculed kinematics (part three)"),
    /* Complete calculed kinematics (part three). */
    for i:1 thru nbrbody do (
        for j:1 thru nbrdof do (
            j_: j,
            vG_: vG[i],
            omega_: omega[i],
            for k: nbrdep step -1 thru 1 do (
                k_: k,
                vG_: subst(pdi[k], pd[k_], vG_),
                vG_: subst(pi[k], p[k_], vG_),
                omega_: subst(pdi[k], pd[k_], omega_),
                omega_: subst(pi[k], p[k_], omega_)
            ),
            
            vGpartial[i, j]: diff(vG_, qd[j_]),
            omegapartial[i, j]: diff(omega_, qd[j_])
        )
    ),
    
    timeKI3: elapsed_run_time(),
    SSKI3: trunc(timeKI3-timeSP2),
    ssKI: ssKI1+ssKI2+SSKI3,
    printf(true, "... Kinematics computation finished ~,3h s.~%", ssKI),
                
    print("Simplification of kinematics parameters (part three)"),
    /* Simplification of kinematics parameters (part three). */
    if SIMPLIFY = 1 then (
        for i:1 thru nbrbody do (
            for j:1 thru nbrdof do (
                vGpartial[i,j]: simplify(vGpartial[i,j]),
                omegapartial[i,j]: simplify(omegapartial[i,j])
            )
        )
    ),
    
    timeSP3: elapsed_run_time(),
    ssSP3: trunc(timeSP3-timeKI3),
    ssSP: ssSP1+ssSP2+ssSP3, 
    printf(true, "... Kinematics simplification finished in ~,3h s.~%", ssSP),
    
    /* Total CPU-time. */
    timeTotal: elapsed_run_time(),
    ss: timeTotal-time0,
    mm: floor(ss/60),
    totseconds:trunc(ss-mm*60),
    printf(true, "All the operations are finished. Total CPU-time in Maxima: ~d:~6,3,,,,'0h min.~%", mm, totseconds),
    
    sysdef: new(sysdef_type),

    sysdef@file: file,
    sysdef@name: title,
    sysdef@nbrdof: nbrdof,
    sysdef@nbrbody: nbrbody,
    sysdef@nbrin: nbrin,
    sysdef@nbrdep: nbrdep,
    sysdef@gravity: makelist(gravity[i], i, 1, 3),
    sysdef@mass: makelist(mass[i], i, 1, nbrbody),
    sysdef@IG: makelist(IG[i], i, 1, nbrbody),
    sysdef@T0G: makelist(T0G[i], i, 1, nbrbody),
    sysdef@vG: makelist(vG[i], i, 1, nbrbody),
    sysdef@omega: makelist(omega[i], i, 1, nbrbody),
    sysdef@aG: makelist(aG[i], i, 1, nbrbody),
    sysdef@omegad: makelist(omegad[i], i, 1, nbrbody),
    sysdef@vGpartial: makelist(makelist(vGpartial[i, j], j, 1, nbrdof), i, 1, nbrbody),
    sysdef@elasticpartial: makelist([], i, 1, nbrbody),
    sysdef@omegapartial: makelist(makelist(omegapartial[i, j], j, 1, nbrdof), i, 1, nbrbody),
    sysdef@BodyRef: makelist(BodyRef[i], i, 1, nbrbody),
    sysdef@ebody: makelist(ebody[i], i, 1, nbrbody),
    sysdef@elastic_dof_idx: makelist(elastic_dof_idx[i], i, 1, nbrbody),
    sysdef@pi: makelist(pi[i], i, 1, nbrdep),
    sysdef@pdi: makelist(pdi[i], i, 1, nbrdep),
    sysdef@pddi: makelist(pddi[i], i, 1, nbrdep),
    sysdef@qi: makelist(qi[i], i, 1, nbrdof),
    sysdef@qdi: makelist(qdi[i], i, 1, nbrdof),
    sysdef@FinalTime: FinalTime,
    sysdef@StepSave: StepSave,
    sysdef@StepMax: StepMax,
    sysdef@appliedF: makelist(appliedF[i], i, 1, nbrbody),
    sysdef@appliedM: makelist(appliedM[i], i, 1, nbrbody),
    sysdef@appliedFe: makelist(appliedFe[i], i, 1, nbrbody),
    sysdef@SIMPLIFY: SIMPLIFY,
    sysdef@u: u,
        
    sysdef
);


do_assign(n_work, e_work):= block([],
    gentran(lrsetq(eval(n_work), scanmap('float, e_work)))
);

cagem2c(sysdef, [target_dir]):= block(
    file: sysdef@file,
    title: sysdef@name,
    nbrdof: sysdef@nbrdof,
    nbrbody: sysdef@nbrbody,
    nbrin: sysdef@nbrin,
    nbrdep: sysdef@nbrdep,
    gravity: sysdef@gravity,
    mass: sysdef@mass,
    IG: sysdef@IG,
    T0G: sysdef@T0G,
    vG: sysdef@vG,
    omega: sysdef@omega,
    aG: sysdef@aG,
    omegad: sysdef@omegad,
    vGpartial: sysdef@vGpartial,
    omegapartial: sysdef@omegapartial,
    BodyRef: sysdef@BodyRef,
    ebody: sysdef@ebody,
    elastic_dof_idx: sysdef@elastic_dof_idx,
    pi: sysdef@pi,
    pdi: sysdef@pdi,
    pddi: sysdef@pddi,
    qi: sysdef@qi,
    qdi: sysdef@qdi,
    FinalTime: sysdef@FinalTime,
    StepSave: sysdef@StepSave,
    StepMax: sysdef@StepMax,
    
    for i:1 thru nbrbody do (
        for j:1 thru nbrdof do (
            j_: j-1,
            vG[i]: subst(qdd[j_], qdd[j], vG[i]),
            vG[i]: subst(qd[j_], qd[j], vG[i]),
            vG[i]: subst(q[j_], q[j], vG[i]),
            omega[i]: subst(qdd[j_], qdd[j], omega[i]),
            omega[i]: subst(qd[j_], qd[j], omega[i]),
            omega[i]: subst(q[j_], q[j], omega[i]),
            aG[i]: subst(qdd[j_], qdd[j], aG[i]),
            aG[i]: subst(qd[j_], qd[j], aG[i]),
            aG[i]: subst(q[j_], q[j], aG[i]),
            omegad[i]: subst(qdd[j_], qdd[j], omegad[i]),
            omegad[i]: subst(qd[j_], qd[j], omegad[i]),
            omegad[i]: subst(q[j_], q[j], omegad[i]),
            T0G[i]: subst(qdd[j_], qdd[j], T0G[i]),
            T0G[i]: subst(qd[j_], qd[j], T0G[i]),
            T0G[i]: subst(q[j_], q[j], T0G[i]),
            vGpartial[i]: subst(qdd[j_], qdd[j], vGpartial[i]),
            vGpartial[i]: subst(qd[j_], qd[j], vGpartial[i]),
            vGpartial[i]: subst(q[j_], q[j], vGpartial[i]),
            omegapartial[i]: subst(qdd[j_], qdd[j], omegapartial[i]),
            omegapartial[i]: subst(qd[j_], qd[j], omegapartial[i]),
            omegapartial[i]: subst(q[j_], q[j], omegapartial[i])
        ),
        for j:1 thru nbrdep do (
            j_: j-1,
            vG[i]: subst(pdd[j_], pdd[j], vG[i]),
            vG[i]: subst(pd[j_], pd[j], vG[i]),
            vG[i]: subst(p[j_], p[j], vG[i]),
            omega[i]: subst(pdd[j_], pdd[j], omega[i]),
            omega[i]: subst(pd[j_], pd[j], omega[i]),
            omega[i]: subst(p[j_], p[j], omega[i]),
            aG[i]: subst(pdd[j_], pdd[j], aG[i]),
            aG[i]: subst(pd[j_], pd[j], aG[i]),
            aG[i]: subst(p[j_], p[j], aG[i]),
            omegad[i]: subst(pdd[j_], pdd[j], omegad[i]),
            omegad[i]: subst(pd[j_], pd[j], omegad[i]),
            omegad[i]: subst(p[j_], p[j], omegad[i]),
            T0G[i]: subst(pdd[j_], pdd[j], T0G[i]),
            T0G[i]: subst(pd[j_], pd[j], T0G[i]),
            T0G[i]: subst(p[j_], p[j], T0G[i]),
            vGpartial[i]: subst(pdd[j_], pdd[j], vGpartial[i]),
            vGpartial[i]: subst(pd[j_], pd[j], vGpartial[i]),
            vGpartial[i]: subst(p[j_], p[j], vGpartial[i]),
            omegapartial[i]: subst(pdd[j_], pdd[j], omegapartial[i]),
            omegapartial[i]: subst(pd[j_], pd[j], omegapartial[i]),
            omegapartial[i]: subst(p[j_], p[j], omegapartial[i])
        )
    ),
    for i:1 thru nbrdep do (
        for j:1 thru nbrdof do (
            j_: j-1,
            pi[i]: subst(qdd[j_], qdd[j], pi[i]),
            pi[i]: subst(qd[j_], qd[j], pi[i]),
            pi[i]: subst(q[j_], q[j], pi[i]),
            pdi[i]: subst(qdd[j_], qdd[j], pdi[i]),
            pdi[i]: subst(qd[j_], qd[j], pdi[i]),
            pdi[i]: subst(q[j_], q[j], pdi[i]),
            pddi[i]: subst(qdd[j_], qdd[j], pddi[i]),
            pddi[i]: subst(qd[j_], qd[j], pddi[i]),
            pddi[i]: subst(q[j_], q[j], pddi[i])
        ),
        for j:1 thru nbrdep do (
            j_: j-1,
            pi[i]: subst(pdd[j_], pdd[j], pi[i]),
            pi[i]: subst(pd[j_], pd[j], pi[i]),
            pi[i]: subst(p[j_], p[j], pi[i]),
            pdi[i]: subst(pdd[j_], pdd[j], pdi[i]),
            pdi[i]: subst(pd[j_], pd[j], pdi[i]),
            pdi[i]: subst(p[j_], p[j], pdi[i]),
            pddi[i]: subst(pdd[j_], pdd[j], pddi[i]),
            pddi[i]: subst(pd[j_], pd[j], pddi[i]),
            pddi[i]: subst(p[j_], p[j], pddi[i])
        )
    ),
    
    filepath: pathname_directory(file),
    if length(target_dir)>0 then (
        filepath: target_dir[1],
        if slength(filepath)>0 then
            if notequal(substring (filepath, slength(filepath), slength(filepath)+1),"/") then
                filepath: sconcat(filepath, "/")
    ),
    filename: pathname_name(file),
    
    load("gentran"),
    gentranlang(c),
    on('float),
    off('gentranseg),
    ?clinelen\*: 1000,            
    user_file: sconcat(filename, ".AppEff.hpp"),
    gentranin(filename_merge(cagem_dir, "cadyn_cpp.tem"), [openw(sconcat(filepath, filename, "System.hpp"))]),
                                      
    app_file: sconcat(filepath, filename, "_app.cpp"),
    if file_search(app_file)=false then
        gentranin(filename_merge(cagem_dir, "cadyn_cpp_app.tem"), [openw(app_file)])
);


cross(a, b):= [
    a[2]*b[3]-a[3]*b[2],
    a[3]*b[1]-a[1]*b[3],
    a[1]*b[2]-a[2]*b[1]
];

crossmat(x):= block(
    x: flatten(args(x)),
    matrix([0, -x[3], x[2]], [x[3], 0, -x[1]], [-x[2], x[1], 0])
);

/* TODO: add frames and ksigma */
defstruct(modal (refmod, I, md, Ct, Cr, Me, Gr, Oe, Ge, K, D));
defstruct(mtaylor (order, nrow, ncol, nelem, nq, nqn, struct, M0, M1, Mn));
defstruct(refmod (mass, nelastq, ielastq));

makeEmptyTaylor(order, nrow, ncol, nelem, nq, nqn, struct):= block([t],
    t: new(mtaylor),
    t@order: order,
    t@nrow: nrow,
    t@ncol: ncol,
    t@nelem: nelem,
    t@nq: nq,
    t@nqn: nqn,
    t@struct: struct,
    
    if nelem>0 then
        t@M0: makelist(zeromatrix(nrow, ncol), i, 1, nelem)
    else
        t@M0: zeromatrix(nrow, ncol),
    
    if order>0 then
        t@M1: makelist(copy(t@M0), i, 1, nq),
            
    if order>1 then
        error("Elements of class taylor with order > 1 currently not supported"),
            
    t
);

emptyElasticMode(nedof):= block([b, rm],
    b: new(modal),
    
    rm: new(refmod),
    
    rm@mass: 0,
    rm@nelastq: nedof,
    rm@ielastq: makelist(sconcat("Noname DOF", i), i, 1, nedof),
    
    b@refmod: rm,
    
    b@md: makeEmptyTaylor(1, 3, 1, 0, nedof, 0, 3),
    b@I: makeEmptyTaylor(1, 3, 3, 0, nedof, 0, 2), /* 2nd order element currently not supported */
    b@Ct: makeEmptyTaylor(1, nedof, 3, 0, nedof, 0, 3),
    b@Cr: makeEmptyTaylor(1, nedof, 3, 0, nedof, 0, 3),
    b@Me: makeEmptyTaylor(0, nedof, nedof, 0, nedof, 0, 2),
    b@Gr: makeEmptyTaylor(1, 3, 3, nedof, nedof, 0, 3),
    b@Ge: makeEmptyTaylor(0, nedof, 3, nedof, nedof, 0, 3),
    b@Oe: makeEmptyTaylor(1, nedof, 6, 0, nedof, 0, 3),
    b@K: makeEmptyTaylor(1, nedof, nedof, 0, nedof, 0, 2),
    b@D: makeEmptyTaylor(0, nedof, nedof, 0, nedof, 0, 2),

    b
);

genericEmptyTaylor(order, nrow, ncol, nelem, nq, nqn, struct, name):= block([t],
    t: new(mtaylor),
    t@order: order,
    t@nrow: nrow,
    t@ncol: ncol,
    t@nelem: nelem,
    t@nq: nq,
    t@nqn: nqn,
    t@struct: struct,
    
    name: eval_string(concat("'", name)),
    
    /* TODO: consider symmetric matrices */
    if nelem>0 then
        t@M0: makelist(genmatrix(lambda([i, j], concat(name, "0_", k, "__", i, "_", j)), nrow, ncol), k, 1, nelem)
    else
        t@M0: genmatrix(lambda([i, j], concat(name, "0_", i, "_", j)), nrow, ncol),
    
    if order>0 then
        if nelem>0 then
            t@M1: makelist(makelist(genmatrix(lambda([i, j], concat(name, "1_", l, "_", k, "__", i, "_", j)), nrow, ncol), k, 1, nelem), l, 1, nq)
        else
            t@M1: makelist(genmatrix(lambda([i, j], concat(name, "1_", l, "__", i, "_", j)), nrow, ncol), l, 1, nq),
        
            
    if order>1 then
        error("Elements of class taylor with order > 1 currently not supported"),
            
    t
);

genericElasticMode(nedof, name):= block([b, rm],
    b: new(modal),
    
    rm: new(refmod),
    
    rm@mass: eval_string(concat("'", name, "_mass")),
    rm@nelastq: nedof,
    rm@ielastq: makelist(sconcat(name, " DOF", i), i, 1, nedof),
    
    b@refmod: rm,
    
    b@md: genericEmptyTaylor(1, 3, 1, 0, nedof, 0, 3, concat(name, "_md")),
    b@I: genericEmptyTaylor(1, 3, 3, 0, nedof, 0, 2, concat(name, "_I")), /* 2nd order element currently not supported */
    b@Ct: genericEmptyTaylor(1, nedof, 3, 0, nedof, 0, 3, concat(name, "_Ct")),
    b@Cr: genericEmptyTaylor(1, nedof, 3, 0, nedof, 0, 3, concat(name, "_Cr")),
    b@Me: genericEmptyTaylor(0, nedof, nedof, 0, nedof, 0, 2, concat(name, "_Me")),
    b@Gr: genericEmptyTaylor(1, 3, 3, nedof, nedof, 0, 3, concat(name, "_Gr")),
    b@Ge: genericEmptyTaylor(0, nedof, 3, nedof, nedof, 0, 3, concat(name, "_Ge")),
    b@Oe: genericEmptyTaylor(1, nedof, 6, 0, nedof, 0, 3, concat(name, "_Oe")),
    b@K: genericEmptyTaylor(1, nedof, nedof, 0, nedof, 0, 2, concat(name, "_K")),
    b@D: genericEmptyTaylor(0, nedof, nedof, 0, nedof, 0, 2, concat(name, "_D")),

    b
);

calcElasticModeLumpedPrecomputed(PHI, rr, mm):= block([b, i, iPHI, jPHI, md, Ct, Cr, Me, Mee, Gr, Oe, Ge, Gee], 
    b: emptyElasticMode(length(PHI)),
    
    m: 0,
    for i:1 thru length(PHI[1]) do (
        m: m + mm[i]
    ),
    b@refmod@mass: m,
    
    I: zeromatrix(3, 3),
    for i:1 thru length(PHI[1]) do (
        I: I - crossmat(rr[i]).crossmat(rr[i])*mm[i]
    ),
    b@I@M0: I,
    
    md: zeromatrix(3, 1),
    for i:1 thru length(PHI[1]) do (
        md: md + transpose(matrix(rr[i]*mm[i]))
    ),
    b@md@M0: md,
    
    b@Ct@M0: zeromatrix(0, 3),
    for iPHI:1 thru length(PHI) do (
        Ct: [0, 0, 0],
        for i:1 thru length(PHI[1]) do (
            Ct: Ct + PHI[iPHI][i]*mm[i]
        ),
        b@Ct@M0: addrow(b@Ct@M0, Ct)
    ),

    b@Cr@M0: zeromatrix(0, 3),
    for iPHI:1 thru length(PHI) do (
        Cr: [0, 0, 0],
        for i:1 thru length(PHI[1]) do (
            Cr: Cr + cross(rr[i], PHI[iPHI][i])*mm[i]
        ),
        b@Cr@M0: addrow(b@Cr@M0, Cr)
    ),

    for iPHI:1 thru length(PHI) do (
        for jPHI:1 thru length(PHI) do (
            Me: 0,
            for i: 1 thru length(PHI[1]) do
                b@Me@M0[iPHI, jPHI]: b@Me@M0[iPHI, jPHI] + apply("+", PHI[iPHI][i]*PHI[jPHI][i])*mm[i]
        )
    ),
    
    for iPHI:1 thru length(PHI) do (
        Gr: zeromatrix(3, 3),
        for i:1 thru length(PHI[1]) do (
            Gr: Gr + 2*transpose(crossmat(rr[i])).crossmat(PHI[iPHI][i])*mm[i]
        ),
        b@Gr@M0[iPHI]: Gr
    ),
        
    for iPHI:1 thru length(PHI) do (
        Gee: zeromatrix(0, 3),
        for jPHI:1 thru length(PHI) do (
            Ge: [0, 0, 0],
            for i: 1 thru length(PHI[1]) do
                Ge: Ge - 2*cross(PHI[iPHI][i], PHI[jPHI][i])*mm[i],
            Gee: addrow(Gee, Ge)
        ),
        b@Ge@M0[iPHI]: Gee
    ),
    
    for iPHI:1 thru length(PHI) do (
        for i:1 thru length(PHI[1]) do (
            b@Oe@M0[iPHI, 1]: b@Oe@M0[iPHI, 1]-(rr[i][3]*PHI[iPHI][i][3] + rr[i][2]*PHI[iPHI][i][2]) * mm[i], /* wx^2 */
            b@Oe@M0[iPHI, 2]: b@Oe@M0[iPHI, 2]-(rr[i][3]*PHI[iPHI][i][3] + rr[i][1]*PHI[iPHI][i][1]) * mm[i], /* wy^2 */
            b@Oe@M0[iPHI, 3]: b@Oe@M0[iPHI, 3]-(rr[i][2]*PHI[iPHI][i][2] + rr[i][1]*PHI[iPHI][i][1]) * mm[i], /* wz^2 */
            b@Oe@M0[iPHI, 4]: b@Oe@M0[iPHI, 4]+(rr[i][1]*PHI[iPHI][i][2] + rr[i][2]*PHI[iPHI][i][1]) * mm[i], /* wx*wy */
            b@Oe@M0[iPHI, 5]: b@Oe@M0[iPHI, 5]+(rr[i][2]*PHI[iPHI][i][3] + rr[i][3]*PHI[iPHI][i][2]) * mm[i], /* wy*wz */
            b@Oe@M0[iPHI, 6]: b@Oe@M0[iPHI, 6]+(rr[i][1]*PHI[iPHI][i][3] + rr[i][3]*PHI[iPHI][i][1]) * mm[i]  /* wx*wz */
        )
    ),
    
    b
);

evalModalTaylor(t, edof_idx):= block([r, i, j],
    r: copy(t@M0),
    
    if t@order>0 then
        for i: 1 thru t@nq do
            if t@nelem>0 then (
                for j: 1 thru t@nelem do
                    r[j]: r[j] + t@M1[i][j]*q[edof_idx[i]]
            ) else
                r: r + t@M1[i]*q[edof_idx[i]],
            
    r
);

simplify_(x):= x;


composeMotion(sysdef):= block([erel, vrel, arel, wrel, wdrel, vGpartial, omegapartial, elasticpartial],
    sysout: copy(sysdef),
    for i: 1 thru sysout@nbrbody do (
        vGpartial: zeromatrix(3, 0),
        omegapartial: zeromatrix(3, 0),
        elasticpartial: zeromatrix(0, sysout@nbrdof),
        for j: 1 thru sysout@nbrdof do (
            vGpartial: addcol(vGpartial, sysout@vGpartial[i][j]),
            omegapartial: addcol(omegapartial, sysout@omegapartial[i][j])
        ),
        sysout@vGpartial[i]: vGpartial,
        sysout@omegapartial[i]: omegapartial,
        
        if numberp(sysout@BodyRef[i]) then (
            erel: simplify_(submatrix(4, sysout@T0G[sysout@BodyRef[i]], 4) . submatrix(4, sysout@T0G[i], 1, 2, 3)),
            vrel: simplify_(submatrix(4, sysout@T0G[sysout@BodyRef[i]], 4) . sysout@vG[i]),
            arel: simplify_(submatrix(4, sysout@T0G[sysout@BodyRef[i]], 4) . sysout@aG[i]),
            wrel: simplify_(submatrix(4, sysout@T0G[sysout@BodyRef[i]], 4) . sysout@omega[i]),
            wdrel: simplify_(submatrix(4, sysout@T0G[sysout@BodyRef[i]], 4) . sysout@omegad[i]),

            sysout@T0G[i]: simplify_(sysout@T0G[sysout@BodyRef[i]] . sysout@T0G[i]),
            sysout@vG[i]: simplify_(sysout@vG[sysout@BodyRef[i]] + crossmat(sysout@omega[sysout@BodyRef[i]]) . erel + vrel),
            sysout@omega[i]: simplify_(sysout@omega[sysout@BodyRef[i]] + wrel),
            sysout@aG[i]: simplify_(sysout@aG[sysout@BodyRef[i]] + crossmat(sysout@omegad[sysout@BodyRef[i]]) . erel + crossmat(sysout@omega[sysout@BodyRef[i]]) . (crossmat(sysout@omega[sysout@BodyRef[i]]) . erel) + 2.0*crossmat(sysout@omega[sysout@BodyRef[i]]) . vrel + arel),
            sysout@omegad[i]: simplify_(sysout@omegad[sysout@BodyRef[i]] + crossmat(sysout@omega[sysout@BodyRef[i]]) . wrel + wdrel),
    
            vGpartial: zeromatrix(3, 0),
            omegapartial: zeromatrix(3, 0),
            for j: 1 thru sysout@nbrdof do (
                vrel: simplify_(submatrix(4, sysout@T0G[sysout@BodyRef[i]], 4) . col(sysout@vGpartial[i], j)),
                wrel: simplify_(submatrix(4, sysout@T0G[sysout@BodyRef[i]], 4) . col(sysout@omegapartial[i], j)),
                vGpartial: simplify_(addcol(vGpartial, col(sysout@vGpartial[sysout@BodyRef[i]], j) + crossmat(col(sysout@omegapartial[sysout@BodyRef[i]], j)) . erel + vrel)),
                omegapartial: simplify_(addcol(omegapartial, col(sysout@omegapartial[sysout@BodyRef[i]], j) + wrel))
            ),
            sysout@vGpartial[i]: vGpartial,
            sysout@omegapartial[i]: omegapartial
        ),
        
        for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
            elasticpartial: addrow(elasticpartial, zeromatrix(1, sysout@nbrdof)),
            elasticpartial[iedof, sysout@elastic_dof_idx[i][iedof]]: 1
        ),
        sysout@elasticpartial[i]: elasticpartial
    ),
    
    sysout
);


computeForceBalance(sysdef):= block([R, MG, PhiG_local, aG_local, omegad_local, omega_local, R_local, MG_local, Re, Ct, Cr, Ct_, Gr, Gr_, w, Ge, Ge_, K, D, grav_local],
    bodyforces: new(bodyforces_type),
    
    for i: 1 thru sysdef@nbrbody do (
        if length(sysout@elastic_dof_idx[i]) = 0 then (
            R[i]: simplify_(sysdef@mass[i] * (sysdef@gravity - sysdef@aG[i])),

            PhiG_local: simplify_(submatrix(4, sysdef@T0G[i], 4) . sysdef@IG[i] . transpose(submatrix(4, sysdef@T0G[i], 4))),
            MG[i]: simplify_(-PhiG_local . sysdef@omegad[i] - crossmat(sysdef@omega[i]) . (PhiG_local . sysdef@omega[i])),
            Re[i]: []
        ) else (
            Re[i]: zeromatrix(length(sysout@elastic_dof_idx[i]), 1),
            aG_local: simplify_(transpose(submatrix(4, sysdef@T0G[i], 4)) . sysdef@aG[i]),
            omegad_local: simplify_(transpose(submatrix(4, sysdef@T0G[i], 4)) . sysdef@omegad[i]),
            omega_local: simplify_(transpose(submatrix(4, sysdef@T0G[i], 4)) . sysdef@omega[i]),

            R_local: simplify_(- sysdef@ebody[i]@refmod@mass * aG_local),
            R_local: simplify_(R_local - crossmat(omegad_local) . evalModalTaylor(sysdef@ebody[i]@md, sysdef@elastic_dof_idx[i])),
            Ct: evalModalTaylor(sysdef@ebody[i]@Ct, sysdef@elastic_dof_idx[i]),
            for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                R_local: R_local - transpose(row(Ct, iedof)) * qdd[sysout@elastic_dof_idx[i][iedof]]
            ),
            
            MG_local: simplify_(- evalModalTaylor(sysdef@ebody[i]@I, sysdef@elastic_dof_idx[i]) . omegad_local),
            MG_local: simplify_(MG_local - crossmat(evalModalTaylor(sysdef@ebody[i]@md, sysdef@elastic_dof_idx[i])) . aG_local),
            Cr: evalModalTaylor(sysdef@ebody[i]@Cr, sysdef@elastic_dof_idx[i]),
            for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                MG_local: MG_local - transpose(row(Cr, iedof)) * qdd[sysout@elastic_dof_idx[i][iedof]]
            ),
            for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                Re[i][iedof, 1]: simplify_(- row(Ct, iedof) . aG_local),
                Re[i][iedof, 1]: simplify_(Re[i][iedof, 1] - row(Cr, iedof) . omegad_local),
                for jedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                    Re[i][iedof, 1]: simplify_(Re[i][iedof, 1] - sysdef@ebody[i]@Me@M0[iedof, jedof] * qdd[sysout@elastic_dof_idx[i][jedof]])
                )
            ),
            R_local: R_local - simplify_(crossmat(omega_local) . (crossmat(evalModalTaylor(sysdef@ebody[i]@md, sysdef@elastic_dof_idx[i])) . omega_local)),
            Ct_: zeromatrix(3, 1),
            for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                Ct_: Ct_ + transpose(row(Ct, iedof)) * qd[sysout@elastic_dof_idx[i][iedof]]
            ),
            R_local: R_local - simplify_(2 * crossmat(omega_local) . Ct_),

            MG_local: MG_local - simplify_(crossmat(omega_local) . (evalModalTaylor(sysdef@ebody[i]@I, sysdef@elastic_dof_idx[i]) . omega_local)),
            Gr_: zeromatrix(3, 3),
            Gr: evalModalTaylor(sysdef@ebody[i]@Gr, sysdef@elastic_dof_idx[i]),
            for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                Gr_: Gr_ + Gr[iedof] * qd[sysout@elastic_dof_idx[i][iedof]]
            ),
            MG_local: MG_local - simplify_(Gr_ . omega_local),

            w: matrix([omega_local[1, 1]*omega_local[1, 1], omega_local[2, 1]*omega_local[2, 1], omega_local[3, 1]*omega_local[3, 1], omega_local[1, 1]*omega_local[2, 1], omega_local[2, 1]*omega_local[3, 1], omega_local[1, 1]*omega_local[3, 1]]),

            Re[i]: Re[i] - simplify_(evalModalTaylor(sysdef@ebody[i]@Oe, sysdef@elastic_dof_idx[i]) . transpose(w)),
            Ge: evalModalTaylor(sysdef@ebody[i]@Ge, sysdef@elastic_dof_idx[i]),
            for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                Ge_: zeromatrix(3, 1),
                for jedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                    /* TODO: check for correct order of jedof and iedof */
                    Ge_: Ge_ + transpose(row(Ge[jedof], iedof)) * qd[sysout@elastic_dof_idx[i][iedof]]
                ),
                Re[i][iedof, 1]: Re[i][iedof, 1] - simplify_(transpose(Ge_) . omega_local)
            ),

            K: evalModalTaylor(sysdef@ebody[i]@K, sysdef@elastic_dof_idx[i]),
            D: evalModalTaylor(sysdef@ebody[i]@D, sysdef@elastic_dof_idx[i]),
            for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                /* TODO currently only diagonal stiffness and damping matrices supported */
                Re[i][iedof, 1]: Re[i][iedof, 1] - K[iedof, iedof] * q[sysout@elastic_dof_idx[i][iedof]],
                Re[i][iedof, 1]: Re[i][iedof, 1] - D[iedof, iedof] * qd[sysout@elastic_dof_idx[i][iedof]]
            ),

            R[i]: simplify_(submatrix(4, sysdef@T0G[i], 4) . R_local),
            MG[i]: simplify_(submatrix(4, sysdef@T0G[i], 4) . MG_local),
            
            R[i]: R[i] + sysdef@ebody[i]@refmod@mass * sysdef@gravity,

            grav_local: transpose(submatrix(4, sysdef@T0G[i], 4)) . sysdef@gravity,
            MG[i]: MG[i] + simplify_(submatrix(4, sysdef@T0G[i], 4) . crossmat(evalModalTaylor(sysdef@ebody[i]@md, sysdef@elastic_dof_idx[i])) . grav_local),
            for iedof: 1 thru length(sysout@elastic_dof_idx[i]) do (
                Re[i][iedof, 1]: Re[i][iedof, 1] + simplify_(row(Ct, iedof) . grav_local)
            )
        )
    ),
    bodyforces@R: makelist(R[i], i, 1, sysdef@nbrbody),
    bodyforces@MG: makelist(MG[i], i, 1, sysdef@nbrbody),
    bodyforces@Re: makelist(Re[i], i, 1, sysdef@nbrbody),
    
    bodyforces
);


generalizedBalance(sysdef, bodyforces):= block([],
    f: zeromatrix(sysdef@nbrdof, 1),
    
    for i: 1 thru sysdef@nbrbody do (
        f: f - simplify_(transpose(sysdef@vGpartial[i]) . bodyforces@R[i]),
        f: f - simplify_(transpose(sysdef@omegapartial[i]) . bodyforces@MG[i]),
        
        if length(sysdef@elastic_dof_idx[i]) > 0 then (
            f: f - simplify_(transpose(sysdef@elasticpartial[i]) . bodyforces@Re[i])
        )
        /*
        for iedof: 1 thru length(sysdef@elastic_dof_idx[i]) do (
            f[sysdef@elastic_dof_idx[i][iedof], 1]: f[sysdef@elastic_dof_idx[i][iedof]] - bodyforces@Re[i][iedof]
        )
        */
    ),
    
    flatten(args(f))
);

appliedForcesZero(sys):= (
    for i:1 thru sys@nbrbody do (
        appliedF[i]: zeromatrix(3, 1),
        appliedM[i]: zeromatrix(3, 1),
        appliedFe[i]: zeromatrix(length(sys@elastic_dof_idx[i]), 1)
    )
);

linearize(f, u):= block([M, E, A, A1, A2, B, out, f_],
    f_: transpose(matrix(f)),
    M: zeromatrix(length(f_), 0),
    for i: 1 thru length(f_) do (
        M: addcol(M, diff(f_, qdd[i]))
    ),
    E: ratsimp(mat_unblocker(diag_matrix(identfor(M), M))),
    /* E: subst([cos(3*q[2])=0, sin(3*q[2])=0, sin(q[2])=0, cos(q[2])=0, qd[2]^2=0], E)$ */
    /* E: ratsimp(taytorat(taylor(E, [q[0], q[1], qd[0], qd[1]], 0, 0))); */


    A1: zeromatrix(length(f_), 0),
    for i: 1 thru length(f_) do (
        A1: addcol(A1, diff(f_, q[i]))
    ),
    A2: zeromatrix(length(f_), 0),
    for i: 1 thru length(f_) do (
        A2: addcol(A2, diff(f_, qd[i]))
    ),
    A: ratsimp(mat_unblocker(matrix([zerofor(A1), identfor(A1)], [-A1, -A2]))),
    /* A: subst([cos(3*q[2])=0, sin(3*q[2])=0, sin(q[2])=0, cos(q[2])=0, qd[2]^2=0], A)$ */
    /* A: ratsimp(taytorat(taylor(A, [q[0], q[1], qd[0], qd[1]], 0, 0)));*/

    B: zeromatrix(length(f_), 0),
    for i: 1 thru length(u) do (
        B: addcol(B, diff(f_, u[i]))
    ),
    B: ratsimp(mat_unblocker(matrix([zerofor(B)], [-B]))),
    
    out: new(lin_model),
    out@M: M,
    out@E: E,
    out@A: A,
    out@B: B,
    out
);

calcAccelerations(f, M):= block([QDD, f_],
    QDD: transpose(matrix(makelist(qdd[i], i, 1, length(f)))),
    f_: ratsimp(M.QDD-transpose(matrix(f))),
    
    flatten(args(invert(M).f_))
);

writeMATLABMat(fid, name, m):= block([i, j],
    printf(fid, "~a= [~%", name),
    for i: 1 thru length(m) do (
        printf(fid, "    "),
        for j: 1 thru length(transpose(m)) do (
            printf(fid, "~a", (ssubst(")", "]", ssubst("(", "[", string(m[i, j]))))),
            if j#length(transpose(m)) then
                printf(fid, ", ")
        ),
        if i=length(m) then
            printf(fid, "~%")
        else
            printf(fid, ";~%")
    ),
    printf(fid, "];~%")
);

writeMATLAB(file, f, y, lin):= block([i, fid],
    fid: openw(file),
    
    printf(fid, "f= [~%"),
    for i: 1 thru length(f) do (
        printf(fid, "    ~a~%", (ssubst(")", "]", ssubst("(", "[", string(f[i])))))
    ),
    printf(fid, "];~%~%"),

    printf(fid, "y= [~%"),
    for i: 1 thru length(y) do (
        printf(fid, "    ~a~%", (ssubst(")", "]", ssubst("(", "[", string(y[i])))))
    ),
    printf(fid, "];~%"),
    
    if length(lin)>0 and length(lin@E)>0 then (
        printf(fid, "~%"),
        writeMATLABMat(fid, "E", lin@E),
        printf(fid, "~%"),
        writeMATLABMat(fid, "A", lin@A),
        printf(fid, "~%"),
        writeMATLABMat(fid, "B", lin@B)
    ),
    
    close(fid)
);
