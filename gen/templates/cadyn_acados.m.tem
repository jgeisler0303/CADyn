<<block(
    load(cadyn_gen_util),
    file: sysdef@sys_rel@file,
    title: sysdef@sys_rel@name,
    nbrdof: sysdef@sys_rel@nbrdof,
    nbrbody: sysdef@sys_rel@nbrbody,
    nbrdep: sysdef@sys_rel@nbrdep,
    nbrin: sysdef@sys_rel@nbrin,
    states: sysdef@sys_rel@states,
    inputs: sysdef@sys_rel@u,
    out_names: sysdef@sys_rel@out_names,
    u: sysdef@sys_rel@u,
    y: sysdef@outputs,
    external: sysdef@sys_rel@external,
    params: sysdef@all_params,

    f: sysdef@f,
    
    pre_calc_const: sysdef@const_eqns,
    
    subst_list: [],
    if sysdef@sys_rel@default_states=1 then (
        for i:1 thru nbrdof do
            subst_list: endcons(q[i]=concat(q, i), subst_list),
        for i:1 thru nbrdof do
            subst_list: endcons(qd[i]=concat(qd, i), subst_list),
        for i:1 thru nbrdof do
            subst_list: endcons(qdd[i]=concat(qdd, i), subst_list)
    ),
    
    /* Filter unused states */
    eliminate_dof_state: [],
    for i:1 thru nbrdof do (
        if freeof(sysdef@sys_rel@states[i], f) and freeof(sysdef@sys_rel@states[i], y) then
            eliminate_dof_state: endcons(true, eliminate_dof_state)
        else
            eliminate_dof_state: endcons(false, eliminate_dof_state)
    ),
    eliminate_dof_velo: [],
    for i:1 thru nbrdof do (
        if freeof(sysdef@sys_rel@states_dd[i], f) and freeof(sysdef@sys_rel@states_dd[i], y) then
            eliminate_dof_velo: endcons(true, eliminate_dof_velo)
        else
            eliminate_dof_velo: endcons(false, eliminate_dof_velo)
    )
    
)$>><<gentran(literal("%% File generated form template cadyn_acados.m.tem on ", eval(timedate()), ". Do not edit!", cr))$>>
<<gentran(literal("%% Multibody system: ", eval(title), cr, cr))$>>

function [model, index_name]= <<gentran(literal(eval(filename)))$>>_acados(param)

import casadi.*

model = AcadosModel();

% system parameters
stateName= {
<<block([i], 
    for i:1 thru nbrdof do (
        if not(eliminate_dof_state[i]) then (
            if sysdef@sys_rel@default_states=1 then
                gentran(literal("    'q", eval(i), "'", cr))
            else
                gentran(literal("    '", eval(states[i]), "'", cr))
        )
    )
)$>>};
makeCasADiNamedVector('q', stateName, [], 1, 0);

dstateName= {
<<block([i], 
    for i:1 thru nbrdof do (
        if not(eliminate_dof_velo[i]) then (
            if sysdef@sys_rel@default_states=1 then
                gentran(literal("    'qd", eval(i), "'", cr))
            else
                gentran(literal("    '", eval(states[i]), "_d'", cr))
        )
    )
)$>>};
makeCasADiNamedVector('qd', dstateName, [], 1, 0);

ddstateName= {
<<block([i], 
    for i:1 thru nbrdof do (
        if not(eliminate_dof_velo[i]) then (
            if sysdef@sys_rel@default_states=1 then
                gentran(literal("    'qdd", eval(i), "'", cr))
            else
                gentran(literal("    '", eval(states[i]), "_dd'", cr))
        )
    )
)$>>};
makeCasADiNamedVector('qdd', ddstateName, [], 1, 0);

sym_x= [q; qd];

dstateName_= strcat('dot', stateName);
makeCasADiNamedVector('xdot1', dstateName_, [], 1, 0);
sym_xdot= [xdot1; qdd];

inputName= {
<<block([i], 
    for i:1 thru nbrin do (
        gentran(literal("    '", eval(u[i]), "'", cr))
    )
)$>>};
makeCasADiNamedVector('sym_u', inputName, [], 1, 0);
u= sym_u;

% Parameters
paramName= struct();
<<block([i, dims],
    for i:1 thru length(params) do (
        if subvarp(params[i]) then (
            dims: args(params[i]),
            if length(dims)=1 then dims: endcons(1, dims),
            
            gentran(literal("paramName.", eval(op(params[i])), "= ", eval(dims[1]), "*", eval(dims[2]), "\;", cr))
        ) else
            gentran(literal("paramName.", eval(params[i]), "= 1\;", cr))
    )
)$>>
<<block([i], 
    for i:1 thru length(pre_calc_const) do
        gentran(literal("paramName.", eval(first(pre_calc_const[i])), "= 1\;", cr))
)$>>
makeCasADiNamedVector('sym_p', paramName, [], 1, 0);


% external equations
externalNames= {
<<block([i], 
    for i:1 thru length(external) do
        gentran(literal("    '", eval(external[i]), "'", cr))
)$>>};
makeCasADiNamedVector('externals', externalNames, [], 1, 0);
        
<<block([i], 
    if length(external) > 0 then (
        gentran(literal(eval(filename), "_acados_external\;", cr))
    )
)$>>
    

% implicit second order model
<<block([i, i_, opt], 
    ccurrind: 0,

    f_: f,
    for i:1 thru nbrdof do (
        for j:1 thru nbrdof do (
            if eliminate_dof_velo[j] then (
                f_[i]: subst(concat('dot, sysdef@sys_rel@states[j]), sysdef@sys_rel@states_d[j], sys@f[i])
            )
        )
    ),
    for i:1 thru nbrdof do (
        if not(eliminate_dof_velo[i]) and not(eliminate_dof_state[i]) then (
            f_: endcons(concat('dot, sysdef@sys_rel@states[i])-sysdef@sys_rel@states_d[i], f_)
        )
    ),
    
    opt: genopt([f_], f_temp),
    gentran(literal(cr)),

    for i:1 thru length(f_) do (
        do_assign(concat('f, i), opt[1][i])
    ),
    
    gentran(literal("%% Implicit Nonlinear State-Space Model", cr)),
    gentran(literal("f_impl_expr= [")),
    for i:1 thru length(f_) do (
        gentran(literal("f", eval(i))),
        if i<length(f_) then
            gentran(literal(", "))
    ),
    gentran(literal("]'\;", cr))    
)$>>


% Outputs
<<block([opt], 
    ccurrind: 0,
    
    opt: genopt([y], out_temp),
        
    for i:1 thru length(y) do (
        do_assign(concat('sym_y, i), opt[1][i])
    ),
    
    gentran(literal("sym_y= [")),
    for i:1 thru length(y) do (
        gentran(literal("sym_y", eval(i))),
        if i<nbrdof then
            gentran(literal(", "))
    ),
    gentran(literal("]'\;", cr))    
)$>>


% populate structure
model.name= mfilename;
model.u = sym_u;
model.x = sym_x;
model.xdot = sym_xdot;
model.p = sym_p;
model.f_impl_expr = f_impl_expr;

% indices and names
index_name.name= {
<<block([i], 
    for i:1 thru nbrdof do (
        if not(eliminate_dof_state[i]) then (
            if sysdef@sys_rel@default_states=1 then
                gentran(literal("    'q", eval(i), "'", cr))
            else
                gentran(literal("    '", eval(states[i]), "'", cr))
        )
    ),
    for i:1 thru nbrdof do (
        if not(eliminate_dof_velo[i]) then (
            if sysdef@sys_rel@default_states=1 then
                gentran(literal("    'qd", eval(i), "'", cr))
            else
                gentran(literal("    '", eval(states[i]), "_d'", cr))
        )
    )
)$>>};

<<block([i, idx],
    idx: 1,
    for i:1 thru nbrdof do (
        if not(eliminate_dof_state[i]) then (
            if sysdef@sys_rel@default_states=1 then
                gentran(literal("index_name.idx.q", eval(i), "= ", eval(idx), "\;", cr))
            else
                gentran(literal("index_name.idx.", eval(states[i]), "= ", eval(idx), "\;", cr)),
            idx: idx+1
        )
    ),
    for i:1 thru nbrdof do (
        if not(eliminate_dof_velo[i]) then (
            if sysdef@sys_rel@default_states=1 then
                gentran(literal("index_name.idx.qd", eval(i), "= ", eval(idx), "\;", cr))
            else
                gentran(literal("index_name.idx.", eval(states[i]), "_d= ", eval(idx), "\;", cr)),
            idx: idx+1
        )
    )
)$>>
end


function model= makeCasADiNamedVector(vec_name, names, model, unpack, uses_sx)
if ~exist('unpack', 'var')
    unpack= false;
end

if isstruct(names)
    s= names;
    names= fieldnames(s);
    sizes= zeros(size(names));
    for i= 1:length(names)
        sizes(i)= s.(names{i});
    end
else
    sizes= ones(size(names));
end

n= sum(sizes);
model.([vec_name '_names'])= names;
model.([vec_name '_sizes'])= sizes;
model.([vec_name '_indices'])= [0; cumsum(sizes(1:end-1))];

model.(['n' vec_name])= n;
if unpack, assignin('caller', ['n' vec_name], n); end
if exist('uses_sx', 'var') && uses_sx
    model.(vec_name)= casadi.SX.sym(vec_name, n);
else
    model.(vec_name)= casadi.MX.sym(vec_name, n);
end
if unpack, assignin('caller', vec_name, model.(vec_name)); end

for i= 1:length(names)
    idx= sum(sizes(1:i-1))+1;
    model.(['i' vec_name '_' names{i}])= idx;
    if unpack, evalin('caller', sprintf('i%s_%s= %d;', vec_name, names{i}, i)); end
    
    model.([vec_name '_by_name']).(names{i})= model.(vec_name)((1:sizes(i))+idx-1);
    if unpack, evalin('caller', sprintf('%s= %s(%d:%d);', names{i}, vec_name, idx, idx+sizes(i)-1)); end
end

end

function p= pow(b, e)
p= b^e;
end
