#include "ODEOrder2.hpp"
#include <map>
#include <string>
#include <stdexcept>
#include <utility>
#include <cassert>
#include <fstream>
#include <sstream>

<<gentran(literal("\/\* File generated form template cadyn2_cpp.tem on ", eval(timedate()), ". Do not edit! \*\/", cr))>>
<<gentran(literal("\/\* Multibody system: ", eval(title), " \*\/", cr, cr))>>

#define mcond(c, a, x, b) ((c)? a:b)

class <<gentran(literal(eval(filename), "System"))>>: public ODEOrder2 {
public:
    static const int nStates= <<gentran(literal(eval(nbrdof)))>>;
    static const int nInputs= <<gentran(literal(eval(nbrin)))>>;
    static const int nbrdep= <<gentran(literal(eval(nbrdep)))>>;
    
    <<gentran(literal(eval(filename), "System"))>>();
    virtual VecX computeResiduals();
    virtual void calcJacobian(double alphaM, double alphaC, double alphaK, double tol);
    void setParam(const std::string &name, const double value);
    double getParam(const std::string &name);
    void setFromFile(const std::string &fileName);
    bool unsetParamsWithMsg();
    
private:
    VecX p, pd, pdd;
    std::map<std::string, std::pair<bool, double *>> paramMap;
    int unsetParams;
    
    
<<block([i], 
    for i:1 thru length(params) do (
        gentran(literal("    double ", eval(params[i]), "\;", cr))
    )
)>>
};

const int <<gentran(literal(eval(filename)))>>System::nbrdep;

<<gentran(literal(eval(filename)))>>System::<<gentran(literal(eval(filename)))>>System() : 
    ODEOrder2(nStates, nInputs, "<<gentran(literal(eval(filename)))>>", "<<gentran(literal(eval(title)))>>"),
    p(nbrdep),
    pd(nbrdep),
    pdd(nbrdep)
{
<<block([i], 
    for i:1 thru length(params) do (
        pname: string(params[i]),
        if smismatch ("p_", pname)=3 then
            pname: substring(pname, 3),
        gentran(literal("    paramMap.emplace(\"", eval(pname), "\", std::make_pair(true, &", eval(params[i]), "))\;", cr))
    ),
    gentran(literal(cr)),
    gentran(literal("    unsetParams= ", eval(length(params)), "\;", cr))    
)>>
}

VecX <<gentran(literal(eval(filename)))>>System::computeResiduals() {
    VecX f_(nbrdof);
    
    if(unsetParams)
        throw std::runtime_error("Cannot simulate with unset parameters.");
    
    // TODO write constant values only once
<<block([i, i_, opt], 
    ?ccurrind\*: 8,

    if nbrdep > 0 then (
        gentran(literal("    // Dependant variables", cr)),
        gentran("    {", literal(cr)),
                    
        opt: genopt([pi, pdi, pddi]),
        gentran(literal(cr)),

        for i:1 thru nbrdep do (
            i_: i-1,
            do_assign('p[i_], opt[1][i]),
            do_assign('pd[i_], opt[2][i]),
            do_assign('pdd[i_], opt[3][i]),
            gentran(literal(cr))
        ),
        gentran("    }", literal(cr))        
    )
)>>

    {
<<block([i, i_, opt], 
    ?ccurrind\*: 8,

    opt: genopt([f]),
    gentran(literal(cr)),

    for i:1 thru nbrdof do (
        i_: i-1,
        do_assign(concat("f_[", i_, "]"), opt[1][i])
    )
)>>
    }

    return f_;
}

void <<gentran(literal(eval(filename)))>>System::calcJacobian(double alphaM, double alphaC, double alphaK, double tol) {
    MatX M(nbrdof, nbrdof);
    MatX C(nbrdof, nbrdof);
    MatX K(nbrdof, nbrdof);
    
    if(unsetParams)
        throw std::runtime_error("Cannot simulate with unset parameters.");
    
    // TODO write constant values only once
<<block([i, i_, opt], 
    ?ccurrind\*: 8,

    if nbrdep > 0 then (
        gentran(literal("    // Dependant variables", cr)),
        gentran("    {", literal(cr)),
                    
        opt: genopt([pi, pdi, pddi]),
        gentran(literal(cr)),

        for i:1 thru nbrdep do (
            i_: i-1,
            do_assign('p[i_], opt[1][i]),
            do_assign('pd[i_], opt[2][i]),
            do_assign('pdd[i_], opt[3][i]),
            gentran(literal(cr))
        ),
        gentran("    }", literal(cr))        
    )
)>>

    {
<<block([i, i_, j, j_, opt], 
    ?ccurrind\*: 8,
    
    opt: genopt([f, E, A, flatten(args(Ap)), flatten(args(Apd)), flatten(args(Apdd)), flatten(args(dp_dq)), flatten(args(dp_dp)), flatten(args(dpd_dq)), flatten(args(dpd_dp)), flatten(args(dpdd_dq)), flatten(args(dpdd_dqd)), flatten(args(dpdd_dqdd)), flatten(args(dpdd_dp)), flatten(args(dpdd_dpd))]),
    gentran(literal(cr)),

    genmat(opt[2], nbrdof, nbrdof, nbrdof, nbrdof, "M"),
    gentran(literal(cr)),
    genmat(opt[3], nbrdof, nbrdof, nbrdof, 0, "C"),
    gentran(literal(cr)),
    genmat(opt[3], nbrdof, nbrdof, nbrdof, nbrdof, "K"),
    gentran(literal(cr)),

    if nbrdep > 0 then (
        gentran(literal("        // TODO make these fix size matrices", cr)),

        gentran(literal("        MatX Ap(nbrdof, nbrdep)\;", cr)),
        genmat(opt[4], nbrdof, nbrdep, 0, 0, "Ap"),
        gentran(literal(cr)),

        gentran(literal("        MatX Apd(nbrdof, nbrdep)\;", cr)),
        genmat(opt[5], nbrdof, nbrdep, 0, 0, "Apd"),
        gentran(literal(cr)),

        gentran(literal("        MatX Apdd(nbrdof, nbrdep)\;", cr)),
        genmat(opt[6], nbrdof, nbrdep, 0, 0, "Apdd"),
        gentran(literal(cr)),

        gentran(literal("        MatX dp_dq(nbrdep, nbrdof)\;", cr)),
        genmat(opt[7], nbrdep, nbrdof, 0, 0, "dp_dq"),
        gentran(literal(cr)),

        gentran(literal("        MatX dp_dp(nbrdep, nbrdep)\;", cr)),
        genmat(opt[8], nbrdep, nbrdep, 0, 0, "dp_dp"),
        gentran(literal(cr)),

        gentran(literal("        MatX dpd_dq(nbrdep, nbrdof)\;", cr)),
        genmat(opt[9], nbrdep, nbrdof, 0, 0, "dpd_dq"),
        gentran(literal(cr)),

        gentran(literal("        MatX dpd_dp(nbrdep, nbrdep)\;", cr)),
        genmat(opt[10], nbrdep, nbrdof, 0, 0, "dpd_dp"),
        gentran(literal(cr)),

        gentran(literal("        MatX dpdd_dq(nbrdep, nbrdof)\;", cr)),
        genmat(opt[11], nbrdep, nbrdof, 0, 0, "dpdd_dq"),
        gentran(literal(cr)),

        gentran(literal("        MatX dpdd_dqd(nbrdep, nbrdof)\;", cr)),
        genmat(opt[12], nbrdep, nbrdof, 0, 0, "dpdd_dqd"),
        gentran(literal(cr)),

        gentran(literal("        MatX dpdd_dqdd(nbrdep, nbrdof)\;", cr)),
        genmat(opt[13], nbrdep, nbrdof, 0, 0, "dpdd_dqdd"),
        gentran(literal(cr)),

        gentran(literal("        MatX dpdd_dp(nbrdep, nbrdep)\;", cr)),
        genmat(opt[14], nbrdep, nbrdep, 0, 0, "dpdd_dp"),
        gentran(literal(cr)),

        gentran(literal("        MatX dpdd_dpd(nbrdep, nbrdep)\;", cr)),
        genmat(opt[15], nbrdep, nbrdep, 0, 0, "dpdd_dpd"),
        gentran(literal(cr)),

        gentran(literal("        dp_dq+= dp_dp*dp_dq\;", cr, cr)),

        gentran(literal("        dpd_dq+= dpd_dp*dp_dq\;", cr)),
        gentran(literal("        dpd_dq+= dp_dp*dpd_dq\; // dpd_dpd= dp_dp", cr)),

        gentran(literal("        dpdd_dq+= dpdd_dp*dp_dq\;", cr)),
        gentran(literal("        dpdd_dq+= dpdd_dpd*dpd_dq\;", cr)),
        gentran(literal("        dpdd_dq+= dp_dp*dpdd_dq\;  // dpdd_dpdd= dp_dp", cr)),

        gentran(literal("        dpdd_dqd+= dpdd_dpd*dp_dq\; // dpd_dqd= dp_dq", cr)),
        gentran(literal("        dpdd_dqd+= dp_dp*dpdd_dqd\;", cr)),

        gentran(literal("        dpdd_dqdd+= dp_dp*dpdd_dqdd\;", cr, cr)),

        gentran(literal("        K+= Ap*dp_dq + Apd*dpd_dq + Apdd*dpdd_dq\;", cr, cr)),
        gentran(literal("        C+= Apd*dp_dq + Apdd*dpdd_dqd\;", cr, cr)),
        gentran(literal("        M+= Apdd*dpdd_dqdd\;", cr, cr))
    ),


    for i:1 thru nbrdof do (
        i_: i-1,
        do_assign(concat("f[", i_, "]"), opt[1][i])
    )
)>>
    }
    
    Jacobian= alphaM*M + alphaC*C + alphaK*K;

    for(int idof= 0; idof < nbrdof; idof++) {
        if(doflocked[idof]) {
            f[idof]= 0.0;
            Jacobian.col(idof).setZero();
        }
    }
}

void <<gentran(literal(eval(filename)))>>System::setParam(const std::string &name, const double value) {
    auto it = paramMap.find(name);
    if(it==paramMap.end())    
        throw std::runtime_error("Unknown parameter \"" + name + "\".");
    
    if(it->second.first) {
        it->second.first= false;
        unsetParams--;
    }
    
    it->second.second[0]= value;
}

double <<gentran(literal(eval(filename)))>>System::getParam(const std::string &name) {
    auto it = paramMap.find(name);
    if(it==paramMap.end())    
        throw std::runtime_error("Unknown parameter \"" + name + "\".");
    
    return it->second.second[0];    
}

void <<gentran(literal(eval(filename)))>>System::setFromFile(const std::string &fileName) {
    std::ifstream infile(fileName);
    
    if(infile.is_open()) {
        int i= 0;
        for(std::string line; std::getline(infile, line);) {
            ++i;
            std::istringstream iss(line);
            
            std::string paramName;
            iss >> paramName;
                
            if(paramName.empty() || (paramName[0]=='*' || paramName[0]=='#')) // comment or empty line
                continue;
            
            double value;
            iss >> value;
            if(iss.fail()) {
                fprintf(stderr, "Could not read value for parameter \"%s\" in line %d.\n", paramName.c_str(), i);
                continue;
            }                
            
            try {
                setParam(paramName, value);
            } catch (const std::exception& e) {
                fprintf(stderr, "Error: %s in line %d.\n", e.what(), i);
                continue;
            }
        }            
    } else
        throw std::runtime_error("Could not open file \"" + fileName + "\"");
}    

bool <<gentran(literal(eval(filename)))>>System::unsetParamsWithMsg() {
    if(unsetParams) {
        fprintf(stderr, "The following parameters are not set:\n");
        for(auto const &i : paramMap) {
            if(i.second.first)
                fprintf(stderr, "%s\n", i.first.c_str());
        }
    }
    
    return unsetParams;
}
